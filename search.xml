<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 下安装Redis]]></title>
    <url>%2F2018%2F10%2F12%2Fnode%2Flinux%2Fnode-linux_08%2F</url>
    <content type="text"><![CDATA[在CentOS7.3下, 安装 Redis 3.2.9 下载Redis wget http://download.redis.io/releases/redis-3.2.9.tar.gz 解压Redis tar -zxvf redis-3.2.9.tar.gz 进入目录, 进行编译测试 cd redis-3.2.9make test 安装到指定目录 make PREFIX=/usr/local/redis install 复制配置文件到安装目录下 cp redis.conf /usr/local/redis/bin 查看目录下的文件列表123456789101112[root@jstu7y7f2y8et7 ~]# cd /usr/local/redis/bin/[root@jstu7y7f2y8et7 bin]# lltotal 15160-rw-r--r-- 1 root root 76 Oct 12 10:27 dump.rdb-rwxr-xr-x 1 root root 2431824 Oct 11 18:01 redis-benchmark-rwxr-xr-x 1 root root 25168 Oct 11 18:01 redis-check-aof-rwxr-xr-x 1 root root 5181840 Oct 11 18:01 redis-check-rdb-rwxr-xr-x 1 root root 2584848 Oct 11 18:01 redis-cli-rw-r--r-- 1 root root 46753 Apr 23 16:09 redis.conf-rw-r--r-- 1 root root 46696 Oct 12 10:29 redis.conf.baklrwxrwxrwx 1 root root 12 Oct 11 18:01 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 5181840 Oct 11 18:01 redis-server redis-benchmark redis性能测试工具redis-check-aof AOF文件修复工具redis-check-rdb RDB文件修复工具redis-cli redis命令行客户端redis.conf redis配置文件redis-sentinal redis集群管理工具redis-server redis服务进程 配置启动方式 vim /usr/local/redis/bin/redis.conf修改 daemonize no –&gt; daemonize yes 启动服务 /usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf 使用 redis-cli 测试123456789[root@jstu7y7f2y8et7 ~]# redis-cli127.0.0.1:6379&gt; set test aaaa(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; set test kkkkOK127.0.0.1:6379&gt; get test&quot;kkkk&quot; auth 输入密码, 进行授权登录]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些惆怅]]></title>
    <url>%2F2018%2F10%2F11%2Fdiary%2Fdiary_0005%2F</url>
    <content type="text"><![CDATA[这几天, 工作强度有点加大. 工作中的一些汹涌的念头, 在工作之余, 再拿出来回味, 却只剩下了几个晦涩的词汇.]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义命令与命令别名]]></title>
    <url>%2F2018%2F10%2F11%2Fnode%2Flinux%2Fnode-linux_07%2F</url>
    <content type="text"><![CDATA[源于我想知道Docker当前运行的容器的IP 首先获取Docker容器IP的命令1sudo docker inspect --format '&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;' 1f7d8f36523c 方法的扩展在 ~/.bashrc 中写一个 bash 函数： 123function docker_ip() &#123; sudo docker inspect --format '&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;' $1&#125; source ~/.bashrc 生效, 然后: docker_ip 1f7d8f36523c 由此之后, 继续的想象因为在Linux下用命令时查看文件列表时用习惯了ll, 换到MacOS后, 却没有ll命令. 经此法, 想试试, 又是好一番寻觅. 编辑 .bash_profile 文件： 1vim ~/.bash_profile 若没有该文件请手动创建。 添加内容 12alias ll='ls -la'alias vi='vim' 立即生效source ~/.bash_profile]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 tar 压缩与解压]]></title>
    <url>%2F2018%2F10%2F11%2Fnode%2Flinux%2Fnode-linux_06%2F</url>
    <content type="text"><![CDATA[Linux 下使用 tar 压缩与解压 解包：tar zxvf FileName.tar打包：tar czvf FileName.tar DirName0\ DirName2\]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot JPA 执行原生 SQL]]></title>
    <url>%2F2018%2F10%2F05%2Farticle%2FSpringBoot%2Farticle-spring-boot_16%2F</url>
    <content type="text"><![CDATA[SpringBoot JPA 执行原生SQL 123456789101112131415161718192021222324252627282930313233343536373839404142package com.yes517.www.dao;import com.yes517.www.entity.OrderSync;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import java.util.List;/** * 订单同步数据库访问接口 */public interface OrderSyncDao extends JpaRepository&lt;OrderSync, Integer&gt; &#123; /** * 获取最后一次同步的记录 * @return */ @Query(value = "SELECT * FROM yslx_erp_order.order_sync ORDER BY id DESC LIMIT 1",nativeQuery=true) OrderSync getLast(); /** * 根据OrderId,获取同步记录 * @return */ @Query(value = "SELECT * FROM yslx_erp_order.order_sync WHERE order_id = ?1",nativeQuery=true) OrderSync getOrderSync(String orderId); /** * 根据OrderId,获取同步记录 * @return */ @Query(value = "SELECT * FROM yslx_erp_order.order_sync WHERE batch_no = ?1",nativeQuery=true) List&lt;OrderSync&gt; getOrderIDsByBatchNo(String batchNo); /** * 根据OrderId,获取同步记录 * @return */ @Query(value = "SELECT COUNT(1) AS COUNT FROM yslx_erp_order.order_sync WHERE status = 0 AND batch_no = ?1",nativeQuery=true) Integer getSyncStatusByBatchNo(String batchNo);&#125; nativeQuery=true 原生SQL ?1 参数]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>JPA</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Jackson Date Format]]></title>
    <url>%2F2018%2F10%2F05%2Farticle%2FSpringBoot%2Farticle-spring-boot_15%2F</url>
    <content type="text"><![CDATA[SpringBoot 中 @ResponseBody 响应JSON时, 对时间类型的格式化 在配置文件中, 添加 jackson 的配置: 123456spring: application: name: orders-sync jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 过滤器中统一处理错误信息]]></title>
    <url>%2F2018%2F10%2F05%2Farticle%2FSpringBoot%2Farticle-spring-boot_14%2F</url>
    <content type="text"><![CDATA[在SpringBoot中, 使用@ControllerAdvice处理Exception时, 过滤器因为尚未进入 @Controller 所以无法触发 @ExceptionHandler. 所以需要在过滤器中特殊处理 过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.yes517.www.filter;import com.yes517.www.common.Constants;import com.yes517.www.utils.DateUtils;import com.yes517.www.utils.rsa.RSAUtils;import com.yes517.www.utils.rsa.SummaryBuilder;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.util.StringUtils;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.text.ParseException;import java.util.*;@Slf4j@Configuration@WebFilter(urlPatterns="/*")@Order(value = 1)public class GlobalFilter implements Filter &#123; private static final Set&lt;String&gt; ALLOWED_PATHS = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList("/erp/error"))); @Autowired Constants constants; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; log.info("初始化过滤器..."); &#125; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; log.info("进入过滤器..."); boolean flag = true; StringBuilder prompt = new StringBuilder(); // 响应错误提示容器 HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; String path = request.getRequestURI().substring(request.getContextPath().length()).replaceAll("[/]+$", ""); boolean allowedPath = ALLOWED_PATHS.contains(path); if (allowedPath) &#123; log.info("错误处理ing..."); chain.doFilter(req, res); &#125; else &#123; log.info("正在验证公共参数..."); String date = request.getHeader("Date"); if (StringUtils.isEmpty(date)) &#123; prompt.append("缺少公共参数[Date], "); flag = false; log.error("缺少公共参数[Date]"); &#125; else &#123; log.info("公共参数Date: &#123;&#125;", date); try &#123; Long l = DateUtils.stringToDateByGMT(date).getTime(); log.info("请求时间: &#123;&#125;", DateUtils.longToString(l, DateUtils.DATETIME)); Long diff = new Date().getTime() - l; if (diff &gt; 0 &amp;&amp; diff &lt;= (10 * 60 * 1000)) &#123; // 验证请求是否超时 log.info("Date 验证通过..."); &#125; else &#123; prompt.append("请求超时, "); flag = false; log.error("请求时间与当前时间相差超过10分钟"); &#125; &#125; catch (ParseException e) &#123; prompt.append("公共参数[Date]格式不正确(eg: Tue, 18 Sep 2018 00:47:39 GMT), "); flag = false; log.error("公共参数[Date]格式不正确..."); &#125; &#125; String accessKey = request.getHeader("AccessKey"); if (StringUtils.isEmpty(accessKey)) &#123; prompt.append("缺少公共参数[AccessKey], "); flag = false; log.error("缺少公共参数[AccessKey]"); &#125; else &#123; if (accessKey.equals(constants.getAccessKey())) &#123; log.info("AccessKey 验证通过..."); &#125; else &#123; prompt.append("公共参数 [AccessKey] 验证失败, "); flag = false; log.error("公共参数 [AccessKey] 验证失败 &#123;&#125;", accessKey); &#125; &#125; String method = request.getHeader("Method"); if (StringUtils.isEmpty(method)) &#123; prompt.append("缺少公共参数[Method], "); flag = false; log.error("缺少公共参数[Method]"); &#125; else &#123; String[] methods = constants.getMethods(); if (methods.length &gt; 0) &#123; if (Arrays.asList(methods).contains(method)) &#123; log.info("Method 验证通过..."); &#125; else &#123; prompt.append("公共参数 [Method] 验证失败, "); flag = false; log.error("公共参数 [Method] 验证失败 &#123;&#125;", method); &#125; &#125; else &#123; prompt.append("系统管理员尚未维护基础数据, 暂时不能进行访问, "); flag = false; log.error("尚未维护可访问的方法名, 不能进行访问"); &#125; &#125; String signature = request.getHeader("Signature"); if (StringUtils.isEmpty(signature)) &#123; prompt.append("缺少公共参数[Signature], "); flag = false; log.error("缺少公共参数[Signature]"); &#125; else &#123; log.info("传入的签名: &#123;&#125;", signature); // 根据参数, 生成摘要 SummaryBuilder summary = new SummaryBuilder(); summary.put("Date", date); summary.put("AccessKey", accessKey); summary.put("Method", method); for (String key: request.getParameterMap().keySet()) &#123; summary.put(key, request.getParameterMap().get(key)[0]); &#125; // 生成签名 try &#123; String s = RSAUtils.encrypt(constants.getSecretKey(), summary.builder()); log.info("生成的签名: &#123;&#125;", s); if (signature.equals(s)) &#123; log.info("Signature 验证通过..."); &#125; else &#123; prompt.append("公共参数 [Signature] 验证失败, "); flag = false; log.error("公共参数 [Signature] 验证失败 &#123;&#125;", signature); &#125; &#125; catch (Exception e) &#123; prompt.append("生成签名失败[").append(e.getMessage()).append("], "); flag = false; log.error("生成签名失败[&#123;&#125;]", e.getMessage()); &#125; &#125; if (flag) &#123; // 公共参数验证通过 log.info("公共参数验证通过..."); chain.doFilter(req, res); &#125; else &#123; // 跳转错误处理 String data = prompt.substring(0, prompt.length() - 2); req.setAttribute("code", 203); req.setAttribute("message", "公共参数验证失败"); req.setAttribute("data", data); req.getRequestDispatcher("/erp/error").forward(req, res); &#125; &#125; &#125; @Override public void destroy() &#123; log.info("过滤器被销毁..."); &#125;&#125; ALLOWED_PATHS 不过滤的路径. req.getRequestDispatcher(&quot;/erp/error&quot;).forward(req, res); 请求转发到Error处理逻辑 Error 处理逻辑12345678910111213141516171819202122232425262728293031323334353637package com.yes517.www.web;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.Map;@Slf4j@Controllerpublic class ErrorController &#123; @RequestMapping(value = &#123;"/erp/error"&#125;, method = RequestMethod.GET) @ResponseBody public Map&lt;String, Object&gt; receive(HttpServletRequest request, HttpServletResponse response) &#123; log.info("处理失败信息..."); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); Integer code = Integer.valueOf(request.getAttribute("code").toString()); String message = request.getAttribute("message").toString(); String data = request.getAttribute("data").toString(); log.info("Error Code: &#123;&#125;", code); log.info("Error Message: &#123;&#125;", message); log.info("Error Data: &#123;&#125;", data); response.setStatus(code); result.put("code", code); result.put("message", message); result.put("data", data); return result; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[退房]]></title>
    <url>%2F2018%2F09%2F17%2Fdiary%2Fdiary_0004%2F</url>
    <content type="text"><![CDATA[这些天, 和舍长合计着合租的事, 就考虑把我现在的房子退了.]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当 Gson 遇到字段不匹配]]></title>
    <url>%2F2018%2F09%2F17%2Fnode%2Fjava%2Fnode-j2se_06%2F</url>
    <content type="text"><![CDATA[最近项目里需要对接淘宝API, 淘宝API的返回结果(json), 与我们项目中定义Bean字段不符. 那就看看Gson 是怎么优雅的解决这个问题的吧. JSON12345678910&#123; "contactor": &#123; "name": "陈***轩", "phone": "1391071****", "post_address": "(北京)(北京市)(海淀区)(**园*街道 北三环中路**号**号楼7**号)(13910717799)(陈轩)", "post_area": "海淀区", "post_city": "北京市", "post_province": "北京" &#125;&#125; Bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.io.Serializable;import java.util.Date;/** * 联系人信息 */public class ContactorInfo implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; /** * 订单号 */ private String orderId; /** * 创建日期 */ private Date createDate; /** * 姓名 */ private String name; /** * 姓名-拼音 */ private String namePinyin; /** * 性别。0-男，1-女 */ private String sex; /** * 出生日期 */ private Date birthday; /** * 国籍 */ private String nationality; /** * 姓（拼音） */ private String surnamePinyin; /** * 名（拼音） */ private String givenNamePinyin; /** * 手机号 */ private String phone; /** * 邮箱 */ private String email; /** * 证件号 */ private String credentialNo; /** * 证件类型 */ private String credentialType; /** * 证件签发国 */ private String issueCountry; /** * 证件签发地 */ private String issuePlace; /** * 证件有效期 */ private String validDate; /** * 收件省 */ private String postProvince; /** * 收件市 */ private String postCity; /** * 收件区 */ private String postArea; /** * 具体收件地址 */ private String postAddress; /** * 个性化信息 */ private String extendAttributes; &#125; 解决方案一:在要转换的字段上, 添加@SerializedName注解. 比如:12345/** * 具体收件地址 */@SerializedName("post_address")private String postAddress; 这种方式, 适用于 只是个别需要转换的情况 解决方案二:如上的例子中, 所有都的Java字段, 都采用驼峰命名, 而JSON却都是用下划线分割的. 这种有规律的就用 FieldNamingPolicy. 比如:1Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create(); Gson提供的枚举类FieldNamingPolicy，该枚举类提供了5种实现方式分别为： FieldNamingPolicy 结果 IDENTITY {“emailAddress”:”yuchen352416@163.com”} LOWER_CASE_WITH_DASHES {“email-address”:”yuchen352416@163.com”} LOWER_CASE_WITH_UNDERSCORES {“email_address”:”yuchen352416@163.com”} UPPER_CAMEL_CASE {“EmailAddress”:”yuchen352416@163.com”} UPPER_CAMEL_CASE_WITH_SPACES {“Email Address”:”yuchen352416@163.com”}]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道常见的面试题]]></title>
    <url>%2F2018%2F09%2F14%2Fnode%2Fjava%2Fnode-j2se_05%2F</url>
    <content type="text"><![CDATA[今天在师兄弟的群里面看到一师弟, 在问面试时, 常常会问到的一题 题目12345678910@Testpublic void test() &#123; Integer a1 = 128; Integer a2 = 128; log.info("&#123;&#125;", a1 == a2); // false Integer b1 = 127; Integer b2 = 127; log.info("&#123;&#125;", b1 == b2); // true&#125; 解释1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; high 可以使用系统属性将值配置为其他值, 默认却是 127 -Djava.lang.Integer.IntegerCache.high = 999 因为比较的是封装类型, 所以 == 比较的是两个对象的引用. b1 与 b2 因为满足 (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) 条件, 所以对象的引用相同的. a1与a2 不满足 (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) 条件, 所以对象是新产生的, 引用不同.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 日志输出]]></title>
    <url>%2F2018%2F09%2F13%2Farticle%2FSpringBoot%2Farticle-spring-boot_13%2F</url>
    <content type="text"><![CDATA[在SpringBoot中使用日志输出 pom.xml中引入jar包依赖12345&lt;!-- 日志依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 给IDEA安装lombok插件安装lombok插件,idea-&gt;file-&gt;seetings-&gt;puugins-&gt;选择Lombok Plugin即可 配置 application.yml12345logging: level: org.springframework.web: INFO com.yes517.www.*: INFO org.hibernate: INFO 例子1234567891011121314151617181920212223242526272829303132333435import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.HashMap;import java.util.Map;@Slf4j@Controllerpublic class WelcomeController &#123; @Autowired Constants constants; @Autowired SessionKey sessionKey; @RequestMapping(value = &#123;"/get"&#125;) @ResponseBody public Object get(ModelMap m) &#123; log.info(sessionKey.getUrl()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("key", constants.getAppKey()); map.put("url", constants.getUrl()); map.put("secret", constants.getAppSecret()); map.put("session", sessionKey.getKey()); return map; &#125;&#125; 使用 @Slf4j 注解后, 在代码里, 就可以直接使用 log对象了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Slf4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忽然不会写删除语句了]]></title>
    <url>%2F2018%2F09%2F12%2Fnode%2Fdatabase%2Fnode-mysql_03%2F</url>
    <content type="text"><![CDATA[今天改了个Bug, 要删除历史数据 写个删除语句1234567DELETE FROM yslx_erp.sys_order_complete WHERE id IN ( SELECT max(id) FROM yslx_erp.sys_order_complete GROUP BY order_id HAVING count(1) &gt; 1); 提示: [HY000][1093] You can’t specify target table ‘sys_order_complete’ for update in FROM clause 记得原来在Oracle中, 写删除时, 这样是可以的呀…. 一脸蒙逼啊….去查了一下,原因MySQL 把查询子句一定要是临时表，不可以是实体表. 修改1234DELETE FROM yslx_erp.sys_order_complete WHERE id IN ( SELECT id FROM (SELECT max(id) as id FROM yslx_erp.sys_order_complete GROUP BY order_id HAVING count(1) &gt; 1) t);COMMIT ;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得思考的一些东西]]></title>
    <url>%2F2018%2F09%2F07%2Fdiary%2Fdiary_0003%2F</url>
    <content type="text"><![CDATA[简明Python教程里看到的 有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷。 ——C.A.R. Hoare 获得人生中的成功需要的专注与坚持不懈多过天才与机会。 ——C.W. Wendte]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次SQL调优的经历]]></title>
    <url>%2F2018%2F09%2F07%2Fnode%2Fdatabase%2Fnode-mysql_02%2F</url>
    <content type="text"><![CDATA[系统随着数据量的增长, 变得越来越慢. 慢到了不能忍受的地步, 故有了这次调优. 查找问题点 从日志里拿出SQL, 执行了一下 10.8s.有点惊呆 开始端详SQL… 将SQL拆开, 一部分一部分的执行. 找到慢的点 影响速度是是一个判断订单状态的子SQL. 执行耗时竟然占用了 7.8s. 处理慢SQL先创建关联条件的联合索引, 试试水. 从 7.8s 减到了 6.3s 又创建了判断条件的联合索引, 这次减到 0.24s. 大喜…. 整体执行 0.37s 创建索引1create index 索引名 on 表名(字段名,字段名);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub 提交不显示提交记录的解决方法]]></title>
    <url>%2F2018%2F09%2F07%2Fnode%2Fnode-git_02%2F</url>
    <content type="text"><![CDATA[GitHub 提交不显示提交记录的解决方法 电脑重装之后，提交代码到GitHub上之后，发现Contribute却没有记录，查看项目确实提交上去了。查资料发现是Git配置的原因。 配置 邮箱地址 git config --global user.email &quot;yuchen352416@163.com&quot; 配置 用户名 git config --global user.name &quot;Selfimpr&quot; 这样再提交代码时，就可以看到记录了。 还有一些常用配置：https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 的一些快捷键]]></title>
    <url>%2F2018%2F09%2F06%2Fnode%2Fjava%2Fnode-j2se_04%2F</url>
    <content type="text"><![CDATA[IDEA 常用的一些快捷键 IDEA 查看类里方法Command + F12 IDEA 打开系统内的命令行Option + F12 IDEA 查看类的继承结构Control + H IDEA 控制台字体Preferences-&gt;Editor-&gt;Colors Scheme-&gt;Console Font]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看刘若英的电影——《后来的我们》]]></title>
    <url>%2F2018%2F09%2F06%2Fdiary%2Fdiary_0002%2F</url>
    <content type="text"><![CDATA[听了陈奕迅的《我们》后， 就有想看《后来的我们》的冲动，看后思潮起伏 &nbsp;&nbsp;&nbsp;&nbsp;故事以回忆的形式展开，我个人还是蛮喜欢这种叙述方式的。讲述了一个关于北漂的故事，讲述了一个程序员的故事。又是井柏然和游戏。 &nbsp;&nbsp;&nbsp;&nbsp;我为什么会说又呢？ &nbsp;&nbsp;&nbsp;&nbsp;刚开始看这部片子的时候，我会拿这部与《微微一笑很倾城》做对比。看到后来，我发现这根本没有可比性啊。《微微一笑很倾城》就像是美丽的童话， 而《后来的我们》更像是在讲述一个真实的北漂程序员的故事。 &nbsp;&nbsp;&nbsp;&nbsp;看到结尾处，已然没有了起初时的对比，更多是回忆，回忆那时观影时的情景，回忆那时身旁的她。我好像被电影里的某个桥段戳中，也在问自己。 &nbsp;&nbsp;&nbsp;&nbsp;如果当时，我有勇气挽留呢？ &nbsp;&nbsp;&nbsp;&nbsp;如果。。。没有如果。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近的一些事]]></title>
    <url>%2F2018%2F09%2F01%2Fdiary%2Fdiary_0001%2F</url>
    <content type="text"><![CDATA[最近的一些人, 一些事的回想与反思 &nbsp;&nbsp;&nbsp;&nbsp;前几天在公司编码, 外屋张姐, 进来跟我说, 改个需求…..巴拉巴拉的说, 说了一会, 我发现, 我竟不能头描述出我对刚才张姐说的需求的理解, 我默默的打开了线上的系统. 指着那个功能跟她描述, 我的理解. 我说了一遍我的理解后, 张姐, 又指着系统的功能, 说了一遍, 她想要的样子. 我发现, 这个需求, 与之前的业务逻辑有冲突的. 我就说这个不能做. &nbsp;&nbsp;&nbsp;&nbsp;我再回想这件事的时候, 发现自己很多地方做的不妥. 我还没的听完, 张姐的说的全部需求, 就去说我对新需求的理解, 给人一种轻浮自大的感觉. 其次, 在了解到真实需求后, 直接向张姐, 说出了结果, 有点敷衍了事的感觉. &nbsp;&nbsp;&nbsp;&nbsp;以后呢, 要把谦卑, 常留心中. 耐心的去听别人说的话. 耐心的去给别人解释原因. &nbsp;&nbsp;&nbsp;&nbsp;昨天看到一篇博文中的一段话, 也是感触颇多. 大概意思是这么说的 &#39;写代码, 是给未来的人, 讲故事. 告诉TA, 你的在做什么事情. 这种跨时空的沟通交流, 才是代码给程序员带来的最大乐趣.&#39; 我非常认同这个说法. 实现功能很容易, 但是别忘了, 写代码不是只为了实现功能呀, 还要明确的告诉后人, 我现在的想法和企图. 这一点, 我在平时的编码过程中, 还很欠缺, 只顾着功能的实现, 而没有考虑代码的易读性. 我会在日后编码过程中, 注意代码的易读性, 毕竟代码是写给后人的呀.]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的百度云服务器上的Docker]]></title>
    <url>%2F2018%2F08%2F29%2Fnode%2Flinux%2Fnode-linux_04%2F</url>
    <content type="text"><![CDATA[今天释怀了我的服务器端口问题之后, 开始搞一些常用的软件 1. 安装Docker因为我的系统是 CentOS 7, Docker 要求 CentOS 系统的内核版本高于 3.10. 所以先查看一下内核版本uname -r满足条件后, 直接安装yum -y install docker . 安装完后, 启动服务…….. 在CentOS 7下, 启动服务不再是 service docker start 这样的方式的.而是: systemctl start docker.service. 设置开机启动: systemctl enable docker.service 2. 下载镜像, 创建容器下载镜像: docker pull centos:6.7 创建容器: docker run --name=linux -d centos:6.7 /bin/bash -c &quot;while true; do echo hello; sleep 1; done&quot; 3. 容器里的事故进入容器: docker exec -ti linux /bin/bash 进入之后本来是想在容器里, 再运行起一个Docker 来玩玩的, 结果发现这条路行不通.原因和解决办法: http://www.wangtianyi.top/blog/2017/01/29/docker-in-docker/ , 我在这找到了答案. 玩不了, 就中规中矩的安装些软件吧. 下载个JDK来玩玩. 先ping 下, 结果 -bash: ping: command not found 我去..心里一万只草泥马, 在奔腾…….还要另安装 yum -y install iputils 看了一下时间, 那边的任务, 估计快执行完了, 这边只能晚上回去继续搞了, 就先记到这…..]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 上安装个小工具]]></title>
    <url>%2F2018%2F08%2F29%2Fnode%2Flinux%2Fnode-linux_05%2F</url>
    <content type="text"><![CDATA[安装个文件上传下载的工具 安装文件上传下载工具 yum install lrzsz sz：将选定的文件发送（send）到本地机器 rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器(receive)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的百度云服务器]]></title>
    <url>%2F2018%2F08%2F27%2Fnode%2Flinux%2Fnode-linux_03%2F</url>
    <content type="text"><![CDATA[前几天, 百度搞活动, 1折促销, 就抢了个服务器. 1. 遇到的问题用公司的网, SSH 登录不了. 2. 漫长的解决之路刚买时, 在公司发工单, 说让我重启路由和电脑, 毕竟不是我自己的网络, 就想晚上回家再试试吧. 晚上回到家里. 结果直接就连上了. 当时就感叹. 这么神奇呀, 换个网络真的可以呀. 这个周末相安无事, 我装了些常用的软件. 今天去到公司, 尝试连了一下, 又不通了. 瞬间感觉有种被坑的感觉. 我尝试 ping 了下, 是通的. 然后 telnet 22 端口, 就不通了. 我TM想哭的心, 都有了. 用 traceroute -d 查了一下路由路径, 也是正常的. 不得不发工单, 问一下情况. 工单里, 我说清楚情况后, 给我的回复是, 让我修改 ssh 的端口. 改了之后, 果然就可以了, 继续追问….无果 3. 在这个过程中, 学到的东西traceroute -d 查询路由路径 修改SSH端口, /etc/ssh/sshd_config 添加 Port=22, Port=1048 保存 重启服务 service sshd restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 之 HelloWord]]></title>
    <url>%2F2018%2F08%2F22%2Fnode%2Fmq%2Fnode-rabbitmq_01%2F</url>
    <content type="text"><![CDATA[RabbitMQ 之 HelloWord RabbitMQ 分为 生产者, 消费者 生产者: 123456789101112131415161718192021222324252627282930313233343536373839package com.yuchen.demo.hello;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.Connection;import com.rabbitmq.client.Channel;public class Send &#123; // 队列名称 private final static String QUEUE_NAME = "lsy_hello"; public static void main(String[] args) throws Exception &#123; // 创建连接连接到MabbitMQ ConnectionFactory factory = new ConnectionFactory(); factory.setHost("10.13.144.24"); factory.setVirtualHost("/"); factory.setPort(5672); factory.setUsername("admin"); factory.setPassword("admin"); // 新建连接 Connection connection = factory.newConnection(); // 建立通道 Channel channel = connection.createChannel(); // 创建队列 (队列名称, 持久化, 仅有1个consumer 与autoDelete配合使用 没有consumer自动删除 , 自动删除, 其他参数) channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发送消息 byte[] // 用户可以把自己的消息序列化成JSON等格式在转成byte[]发送到队列中取出消息后再反序列化得到消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println("发送成功: '" + message + "'"); // 关闭连接 channel.close(); connection.close(); &#125;&#125; 生产者, 向指定的消息通道(队列)中, 插入消息 消费者: 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.yuchen.demo.hello;import java.io.IOException;import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.Consumer;import com.rabbitmq.client.DefaultConsumer;import com.rabbitmq.client.Envelope;public class MessageConsumer &#123; // 队列名称 private final static String QUEUE_NAME = "lsy_hello"; public static void main(String[] args) throws Exception &#123; // 创建连接连接到MabbitMQ ConnectionFactory factory = new ConnectionFactory(); factory.setHost("10.13.144.24"); factory.setVirtualHost("/"); factory.setPort(5672); factory.setUsername("admin"); factory.setPassword("admin"); // 新建连接 Connection connection = factory.newConnection(); // 建立通道 Channel channel = connection.createChannel(); // 声明队列, 可能在发送方之前启动接收方, 确保队列存在。 channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(" [*] Waiting for messages. To exit press CTRL+C"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, "UTF-8"); System.out.println("接收到远端消息: '" + message + "'"); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 消费者, 从指定的消息通道(队列)中, 读取消息. 阻塞监听指定队列的消息]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(单例模式)]]></title>
    <url>%2F2018%2F08%2F19%2Farticle%2FDesignPattern%2Fdesign-pattern_01%2F</url>
    <content type="text"><![CDATA[设计模式之单例模式 饿汉式单例模式12345678910111213141516171819package pro.yuchen.singleton;/** * 饿汉式单例模式 */public class SingletonDemo_01 &#123; private static SingletonDemo_01 instance = new SingletonDemo_01(); private SingletonDemo_01() &#123; if(null != instance) &#123; throw new RuntimeException(); // 防反射调用 &#125; &#125; public static SingletonDemo_01 getInstance() &#123; return instance; &#125;&#125; 线程安全: 是 延迟加载: 否 调用效率: 高 懒汉式单例模式12345678910111213141516171819202122package pro.yuchen.singleton;/** * 懒汉式单例模式 */public class SingletonDemo_02 &#123; private static SingletonDemo_02 instance = null; private SingletonDemo_02() &#123; if(null != instance) &#123; throw new RuntimeException(); // 防反射调用 &#125; &#125; public static synchronized SingletonDemo_02 getInstance() &#123; if (null == instance) &#123; instance = new SingletonDemo_02(); &#125; return instance; &#125;&#125; 线程安全: 是 延迟加载: 是 调用效率: 低 双重检查琐式单例模式123456789101112131415161718192021222324252627282930313233package pro.yuchen.singleton;/** * 双重检查琐式单例模式 */public class SingletonDemo_03 &#123; private static SingletonDemo_03 instance = null; private SingletonDemo_03() &#123; if(null != instance) &#123; throw new RuntimeException(); // 防反射调用 &#125; &#125; public static SingletonDemo_03 getInstance() &#123; if (null == instance) &#123; SingletonDemo_03 s; synchronized (SingletonDemo_03.class) &#123; s = instance; if (s == null) &#123; synchronized (SingletonDemo_03.class) &#123; if (s == null) &#123; s = new SingletonDemo_03(); &#125; &#125; instance = s; &#125; &#125; &#125; return instance; &#125;&#125; 由于JVM底层, 不支持, 所以不建议这么写 静态内部类单例模式1234567891011121314151617package pro.yuchen.singleton;/** * 静态内部类单例模式 */public class SingletonDemo_04 &#123; private static class SingletonInstance &#123; private static final SingletonDemo_04 instance = new SingletonDemo_04(); &#125; private SingletonDemo_04() &#123; &#125; public static synchronized SingletonDemo_04 getInstance() &#123; return SingletonInstance.instance; &#125;&#125; 线程安全: 是 延迟加载: 是 调用效率: 高 枚举类型单例模式1234567891011121314package pro.yuchen.singleton;/** * 静态内部类单例模式 */public enum SingletonDemo_05 &#123; INSTANCE; // 返回本身 public void operation() &#123; System.out.println("......"); &#125;&#125; 线程安全: 是 延迟加载: 否 调用效率: 高 关于反射通过反射创建单例对象123456789101112131415161718192021@org.junit.Testpublic void test_reflection() &#123; // 通过反射, 破单例 try &#123; Class&lt;SingletonDemo_04&gt; clazz = (Class&lt;SingletonDemo_04&gt;) Class.forName("pro.yuchen.singleton.SingletonDemo_04"); Constructor&lt;SingletonDemo_04&gt; constructor = clazz.getDeclaredConstructor(null); constructor.setAccessible(true); // 忽略访问权限 SingletonDemo_04 s = constructor.newInstance(); System.out.println(s); System.out.println(SingletonDemo_04.getInstance()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125; 应对之法12345private SingletonDemo_04() &#123; // 应对反射创建对象 if (SingletonInstance.instance != null) &#123; throw new RuntimeException(); &#125;&#125; 关于序列化通过反序列化创建单例对象12345678910111213141516171819202122232425262728@org.junit.Testpublic void test_serializable() &#123; // 测试序列化, 破单例 byte[] bytes = null; try &#123; // 将对象序列化到内存中 SingletonDemo_04 s = SingletonDemo_04.getInstance(); System.out.println(s); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(s); bytes = bos.toByteArray(); oos.close(); bos.close(); System.out.println(bytes); // 将内存中的序列化数组, 反序列化为对象 ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); SingletonDemo_04 s1 = (SingletonDemo_04) ois.readObject(); System.out.println(s1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 应对之法123private Object readResolve() throws ObjectStreamException &#123; // 应对反序列化创建对象 return SingletonInstance.instance;&#125; SingletonDemo_04 重写 readResolve 方法 多线程环境下测试1234567891011121314151617181920212223@org.junit.Testpublic void test_much_thread() throws InterruptedException &#123; long start = System.currentTimeMillis(); int max = 1000; final CountDownLatch count = new CountDownLatch(max); for (int i = 0; i &lt; max; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123;// Object o = SingletonDemo_01.getInstance(); // 287// Object o = SingletonDemo_02.getInstance(); // 199// Object o = SingletonDemo_03.getInstance(); // 254// Object o = SingletonDemo_04.getInstance(); // 519 Object o = SingletonDemo_05.INSTANCE; // 274 &#125; count.countDown(); &#125; &#125;).start(); &#125; count.await(); long end = System.currentTimeMillis(); System.out.println("总耗时: " + (end - start));&#125; CountDownLatch 线程阻塞]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式(初窥)]]></title>
    <url>%2F2018%2F08%2F13%2Farticle%2FDesignPattern%2Fdesign-pattern_00%2F</url>
    <content type="text"><![CDATA[关于设计模式的六大原则 单一值守原则里氏替换原则依赖倒置原则接口隔离原则迪米特法则开闭原则]]></content>
      <categories>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决AJAX提交中文信息乱码]]></title>
    <url>%2F2018%2F08%2F08%2Fnode%2Fjava%2Fnode-j2ee_08%2F</url>
    <content type="text"><![CDATA[解决AJAX 提交中文信息乱码 解决AJAX 提交中文信息乱码HTML页面1234567891011121314151617181920&lt;script type="text/javascript"&gt; // 执行保存 var remark = $("#remark").val(); if(remark == undefined) &#123; remark = ""; &#125; // 获取需要展示的数据 $.ajax(&#123; type: "post", url: "/erp/order/ajax/OutlayAndIncomesByOrderId", async: true, datatype:"json", contentType: "application/x-www-form-urlencoded; charset=utf-8", data: &#123;"orderId": orderId, "status": status, "id": id, "remark": remark&#125;, success: function(data) &#123; // 将数据展示到弹出层中 init_review_datas(data, orderId); &#125; &#125;);&lt;/script&gt; type: &quot;post&quot;, 以POST请求方式提交中文 contentType: &quot;application/x-www-form-urlencoded; charset=utf-8&quot; 修改请求体类型和请求体的字符集 Controller123456789101112131415161718@RequestMapping(value = "/order/ajax/ApplyForBatchOutlay", method = &#123; RequestMethod.POST &#125;)@ResponseBodypublic Map&lt;String, String&gt; ajaxApplyForBatchOutlay(HttpServletRequest request, Model model, @RequestBody List&lt;Map&lt;String,Object&gt;&gt; datas) &#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(); if (null == datas) &#123; result.put("msg", "alert-danger"); result.put("data", "请正确填写请款信息..."); return result; &#125; for (Map&lt;String, Object&gt; map : datas) &#123; System.out.println(map); &#125; result.put("msg", "alert-success"); result.put("data", "请款申请成功, 等待财务审核..."); return result;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX 上传JSON数组]]></title>
    <url>%2F2018%2F07%2F24%2Fnode%2Fjava%2Fnode-j2ee_07%2F</url>
    <content type="text"><![CDATA[AJAX 上传JSON数组 AJAX 上传JSON数组HTML页面12345678910111213141516&lt;script type="text/javascript"&gt; $.ajax(&#123; type:"post", url:"/erp/order/ajax/ApplyForBatchOutlay", async:true, datatype:"json", contentType: "application/json; charset=utf-8", data: JSON.stringify(datas), success: function(data) &#123; $("#message").html('&lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;times;&lt;/button&gt;'); $("#message").removeClass("hide"); $("#message").addClass(data.msg); $("#message").html($("#message").html() + data.data); &#125; &#125;);&lt;/script&gt; datatype:&quot;json&quot;, contentType: &quot;application/json; charset=utf-8&quot; 声明数据格式 JSON.stringify(datas) 将JavaScript对象转为 JSON 字符串 Controller123456789101112131415161718@RequestMapping(value = "/order/ajax/ApplyForBatchOutlay", method = &#123; RequestMethod.POST &#125;)@ResponseBodypublic Map&lt;String, String&gt; ajaxApplyForBatchOutlay(HttpServletRequest request, Model model, @RequestBody List&lt;Map&lt;String,Object&gt;&gt; datas) &#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(); if (null == datas) &#123; result.put("msg", "alert-danger"); result.put("data", "请正确填写请款信息..."); return result; &#125; for (Map&lt;String, Object&gt; map : datas) &#123; System.out.println(map); &#125; result.put("msg", "alert-success"); result.put("data", "请款申请成功, 等待财务审核..."); return result;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap 插件(DataTables, DatePicker)]]></title>
    <url>%2F2018%2F07%2F23%2Fnode%2Fjavascript%2Fnode-javascript_18%2F</url>
    <content type="text"><![CDATA[Bootstrap 常用的表格插件(DataTables), 日期插件(DatePicker) 和 下拉列表控件(BootStrap-Select) 表格插件(DataTables) 引入依赖文件 /vendor/datatables/js/jquery.dataTables.min.js /vendor/datatables-plugins/dataTables.bootstrap.min.js /vendor/datatables-responsive/dataTables.responsive.js /vendor/datatables-plugins/dataTables.bootstrap.css /vendor/datatables-responsive/dataTables.responsive.css 实际使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;table width="100%" class="table table-striped table-bordered table-hover" id="tables"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;国家&lt;/th&gt; &lt;th&gt;签证类型&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;请款金额&lt;/th&gt; &lt;th&gt;收款金额&lt;/th&gt; &lt;th&gt;退款金额&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;美国&lt;/td&gt; &lt;td&gt;美国商务签证&lt;/td&gt; &lt;td&gt;江波涛, 杜明, 孙翔, 周泽楷&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;650&lt;/td&gt; &lt;td&gt;900&lt;/td&gt; &lt;td&gt;13&lt;/td&gt; &lt;td&gt;已完成&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt; $(document).ready(function() &#123; $('#dataTables-example').DataTable(&#123; "oLanguage": &#123; "sLengthMenu": "每页显示 _MENU_ 条记录", "sZeroRecords": "对不起，查询不到任何相关数据", "sInfo": "当前显示 _START_ 到 _END_ 条，共 _TOTAL_条记录", "sInfoEmtpy": "找不到相关数据", "sInfoFiltered": "数据表中共为 _MAX_ 条记录)", "sProcessing": "正在加载中...", "sSearch": "搜索", "oPaginate": &#123; "sFirst": "第一页", "sPrevious": " 上一页 ", "sNext": " 下一页 ", "sLast": " 最后一页 " &#125; &#125;, responsive: true, "order": [[ 1, "desc" ]], "columnDefs": [ &#123; "orderable": false, "targets": 0 &#125; ], initComplete: function () &#123; var select = $("#sales"); // 页面上的select控件 var api = this.api(); // 获取api对象 var column = api.column(2); // 获取列对象 column.data().unique().sort().each(function (d, j) &#123; // 遍历列中去重后的数据 select.append( '&lt;option value="'+d+'"&gt;'+d+'&lt;/option&gt;' ); &#125;); &#125; &#125;); &#125;);&lt;/script&gt; 常用配置 &quot;order&quot;: [[ 1, &quot;desc&quot; ]] 默认第二列降序排列 &quot;columnDefs&quot;: [{ &quot;orderable&quot;: false, &quot;targets&quot;: 0 } ] 第一列不进行排序 &quot;initComplete&quot; : function() {} 初始化表格时, 执行的方法 常用方法 自定义检索条件 12345678910111213141516$("#query").on("click", function() &#123; var order_no = isNotNull(document.getElementById("order_no").value); var order_date = isNotNull(document.getElementById("order_date").value); var sales = isNotNull(document.getElementById("sales").value); var name = isNotNull(document.getElementById("name").value); var type = isNotNull($('input[name=type]:checked').val()); var status = isNotNull($('input[name=status]:checked').val()); table.column(0).search(order_no); // 检索列中对就的值 table.column(1).search(order_date); table.column(2).search(sales); table.column(5).search(name); table.column(10).search(type); table.column(17).search(status); table.draw(); // 表格重绘&#125;); 刷新页面后, 回显页码 12345678910111213141516171819$("#dataTables-example").on("page.dt", function() &#123; // 翻页事件 // 计算页码 var table = $("#dataTables-example").dataTable(); var setings = table.fnSettings(); var length = setings._iDisplayLength; // 当前每页显示多少 var start = setings._iDisplayStart; // 当前页开始 var page=(start / length); // 得到页数值 console.log(page); // 将页码存入 Session Storage sessionStorage.setItem("page", page);&#125;).dataTable();$(function() &#123; if(sessionStorage.getItem("page") != null) &#123; var page = sessionStorage.getItem("page"); var table = $("#dataTables-example").dataTable(); table.fnPageChange(Number(page));//加载跳转 &#125;&#125;); 注意: DataTables的配置项中, 要加入 &quot;bDestroy&quot;: true 日期插件(DatePicker) 引入依赖文件 /vendor/bootstrap-datepicker/js/bootstrap-datepicker.js /vendor/bootstrap-datepicker/locales/bootstrap-datepicker.zh-CN.min.js /vendor/bootstrap-datepicker/css/bootstrap-datepicker.css 实际使用 123456789101112131415161718192021222324252627&lt;div class="col-lg-12 "&gt; &lt;div class="col-lg-1 "&gt; &lt;label&gt;开始日期:&lt;/label&gt; &lt;/div&gt; &lt;div class="col-lg-2 "&gt; &lt;input type="text" class="form-control datepicker" data-provide="datepicker" id="start" name="start" value="$&#123;param.start &#125;" /&gt; &lt;/div&gt; &lt;div class="col-lg-1 "&gt; &lt;label&gt;结束日期:&lt;/label&gt; &lt;/div&gt; &lt;div class="col-lg-2 "&gt; &lt;input type="text" class="form-control datepicker" data-provide="datepicker" id="end" name="end" value="$&#123;param.end &#125;" /&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; $('.datepicker').datepicker(&#123; format: 'yyyy-mm', startDate: '-12m', endDate: '0d', language: 'zh-CN', autoclose: true, startView: 'months', maxViewMode:'years', minViewMode:'months' &#125;);&lt;/script&gt; 常用配置 format: &#39;yyyy-mm&#39; 配置日期格式 startDate: &#39;-12m&#39; 配置可选择的开始日期 endDate: &#39;0d&#39; 配置可选择的结束日期 language: &#39;zh-CN&#39; 配置语言 autoclose: true 自动关闭 startView: &#39;months&#39; 开始视图为选择月份 maxViewMode:&#39;years&#39; 最高层视图为 选择年份 minViewMode:&#39;months&#39; 最底层视图为 选择月份 下拉列表控件(BootStrap-Select) 引入依赖文件 /vendor/bootstrap-select/dist/js/bootstrap-select.min.js /vendor/bootstrap-select/dist/js/i18n/defaults-zh_CN.min.js /vendor/bootstrap-select/dist/css/bootstrap-select.min.css 实际使用 123456789&lt;input id="_sales" name="sales" type="hidden" /&gt;&lt;select id="select_sales" class="selectpicker" data-live-search="true" title="--请选择--" multiple onchange="$('#_sales').val($('#select_sales').val().toString())"&gt; &lt;option class="hover-item" value="1"&gt;张三&lt;/option&gt; &lt;option class="hover-item" value="2"&gt;李四&lt;/option&gt; &lt;option class="hover-item" value="3"&gt;王五&lt;/option&gt; &lt;option class="hover-item" value="4"&gt;赵六&lt;/option&gt;&lt;/select&gt; 常用配置 data-live-search=&quot;true&quot; 开启搜索 multiple 开启复选 title=&quot;--请选择--&quot; 默认显示内容 消息回显 1234var str = '1,2,4';var arr = str.split(',');$('#select_sales').selectpicker('val', arr);document.getElementById("_sales").value = str; ​]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 SpringMVC 实现文件的上传和下载]]></title>
    <url>%2F2018%2F07%2F21%2Fnode%2Fjava%2Fnode-j2ee_06%2F</url>
    <content type="text"><![CDATA[使用 SpringMVC 实现文件的上传和下载 1. 文件上传HTML页面1234567891011121314151617181920212223&lt;form id="submit_form" action="/order/save" method="post" enctype="multipart/form-data" &gt; &lt;div class="row"&gt; &lt;div class="col-lg-2 "&gt;&lt;label&gt;附件:&lt;/label&gt;&lt;/div&gt; &lt;div class="col-lg-4 "&gt; &lt;label class="form-inline"&gt; &lt;input type="button" id="openFile" class="btn btn-success" value="选择文件..." /&gt; &lt;input type="file" class="hide" id="annex" name="annex" /&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; $("#openFile").on("click", function() &#123; var annex = document.getElementById("annex"); annex.click(); annex.onchange = function() &#123; var filename = annex.value; filename = filename.substring(12); document.getElementById("openFile").value = filename; &#125; &#125;);&lt;/script&gt; 表单中有文件要上传时, 需要添加 enctype=&quot;multipart/form-data&quot; 属性 Controller123456789101112131415@RequestMapping(value = "/order/save", method = &#123; RequestMethod.POST &#125;)public String save(HttpServletRequest request, Model model, @RequestParam MultipartFile annex) &#123; if (null != annex &amp;&amp; annex.getSize() &gt; 0) &#123; // 保存附件 String fileName = order.getOrderNo() + "_" + annex.getOriginalFilename(); String annexPath = UploadPath.getOrderAnnexPath() + File.separator + fileName; File file = new File(annexPath); try &#123; annex.transferTo(file); // 保存文件到磁盘 &#125; catch (IllegalStateException | IOException e) &#123; e.printStackTrace(); &#125; &#125; return "redirect:/order";&#125; 2. 文件下载Controller12345@RequestMapping(value = "/order/down/annex", method = &#123; RequestMethod.GET &#125;)public void downAnnexByOrderId(HttpServletRequest request, HttpServletResponse response, Integer orderId) &#123; Order order = orderService.get(orderId); ExportUtil.export(order.getAnnexPath(), request, response);&#125; ExportUtil12345678910111213141516171819202122232425262728293031323334353637383940414243public class ExportUtil &#123; private static final Logger logger = Logger.getLogger(ExportUtil.class); public static void export(String filePath, HttpServletRequest request, HttpServletResponse response) &#123; File file = new File(filePath); if(!file.exists())&#123; logger.error("文件不存在"); return; &#125; try &#123; String fileName = file.getName(); String prefix=fileName.substring(fileName.lastIndexOf(".")+1); response.reset(); response.setContentType("application/"+prefix+";charset=UTF-8"); String filenamedisplay = URLEncoder.encode(fileName, "UTF-8"); if (request.getHeader("User-Agent").toLowerCase().indexOf("firefox") &gt; 0) &#123; filenamedisplay = new String(fileName.getBytes("UTF-8"), "ISO8859-1");// firefox浏览器 &#125; else if (request.getHeader("User-Agent").toUpperCase().indexOf("MSIE") &gt; 0) &#123; filenamedisplay = URLEncoder.encode(fileName, "UTF-8");// IE浏览器 &#125; else if (request.getHeader("User-Agent").toUpperCase().indexOf("SAFARI") &gt; 0) &#123; filenamedisplay = new String(fileName.getBytes("UTF-8"), "ISO8859-1");// safari 浏览器 &#125;else if (request.getHeader("User-Agent").toUpperCase().indexOf("CHROME") &gt; 0) &#123; filenamedisplay = new String(fileName.getBytes("UTF-8"), "ISO8859-1");// Chrome浏览器 &#125; long fileLength = new File(filePath).length(); response.setHeader("Content-Disposition", "attachment;filename=\"" + filenamedisplay +"\""); response.setHeader("Content-Length", String.valueOf(fileLength)); BufferedInputStream br = new BufferedInputStream(new FileInputStream(file)); byte[] buf = new byte[1024]; int len = 0; OutputStream out = response.getOutputStream(); while ((len = br.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; out.flush(); br.close(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; HTML1234567&lt;a href="javascript:down_annex(1);"&gt;下载&lt;/a&gt;&lt;script type="text/javascript"&gt; function down_annex(id) &#123; window.location = "/erp/order/down/annex?orderId=" + id; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate 执行原始SQL语句]]></title>
    <url>%2F2018%2F06%2F26%2Fnode%2Fjava%2Fnode-j2ee_05%2F</url>
    <content type="text"><![CDATA[Hibernate 执行select语句, 并将执行结果映射到bean中 上面的查询都是返回标量值的，也就是从resultset中返回的“裸”数据。下面展示如何通过addEntity()让原生查询返回实体对象。 12session.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);session.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[激活 Navicat Premium for Mac]]></title>
    <url>%2F2018%2F06%2F26%2Fnode%2Fnode-navicat-sn%2F</url>
    <content type="text"><![CDATA[激活 Navicat Premium for Mac 1. 准备 ‘公钥/私钥’ 1234567891011121314151617181920212223242526272829303132333435363738-----BEGIN PUBLIC KEY-----MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI/2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF/y3VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/pAgMBAAE=-----END PUBLIC KEY----------BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94/mg/KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa4jRFN/6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz/e0ONlPYrra/DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI/2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF/y3VOqyW1byXFLeZxl7s+Y/SthxOYXzu3mF+2/pAgMBAAECggEAK5qZbYt8wenn1uZg6onRwJ5bfUaJjApL+YAFx/ETtm83z9ByVbx4WWT7CNC7fK1nINy20/mJrOTZkgIxx6otiNC4+DIsACJqol+RLoo8I9pk77Ucybn65ZteOz7hVZIU+8j6LzW0KDt6yowXe75r7G/NEpfibNc3Zz81+oDd2x+bHyGbzc9QcePIVuEzkof6jgpbWrQZU14itx9lVxEgj/fbMccvBx8brR/l9ClmDZd9Y6TWsF1rfJpF3+DPeqFkKCiD7PGz3bs4O/ZdZrfV21ZNVusBW49G6bU63gQVKsOf1qGo3efbAW1HVxgTQ/lExVdcMvdenZm+ADKpL4/wUQKBgQDOfBjn3OC2IerUFu18EgCS7pSjTSibXw+TeX3D5zwszLC091G2rGlT5DihBUhMfesNdpoZynrs4YB6Sz9C3wSGAB8AM/tNvPhtSVtbMHmrdT2DEEKCvLkORNBnt+8aTu2hGRanw9aL1189gzwrmXK5ZuuURfgLrB9ihrvjo4VznQKBgQCapx13dEA1MwapBiIa3k8hVBCoGPsEPWqM33RBdUqUsP33f9/PCx00j/akwmjgQNnBlAJoY7LOqPCyiwOkEf40T4IlHdzYntWQQvHhfBwqSgdkTE9tKj43Ddr7JVFRL6yMSbW39qAp5UX/+VzOLGAlfzJ8CBnkXwGrnKPCVbnZvQKBgQCd+iof80jlcCu3GteVrjxMLkcAbb8cqG1FWpVTNe4/JFgqDHKzPVPUgG6nG2CGTWxxv4UFKHpGE/11E28SHYjbcOpHAH5LqsGy84X2za649JkcVmtclUFMXm/Ietxvl2WNdKF1t4rFMQFIEckOXnd8y/Z/Wcz+OTFF82l7L5ehrQKBgFXl9m7v6e3ijpN5LZ5A1jDL0Yicf2fmePUP9DGbZTZbbGR46SXFpY4ZXEQ9GyVbv9dOT1wN7DXvDeoNXpNVzxzdAIt/H7hN2I8NL+4vEjHG9n4WCJO4v9+yWWvfWWA/m5Y8JqusV1+N0iiQJ6T4btrE4JSVp1P6FSJtmWOKW/T9AoGAcMhPMCL+N+AvWcYt4Y4mhelvDG8e/Jj4U+lwS3g7YmuQuYx7h5tjrS33w4o20g/3XudPMJHhA3z+d8b3GaVM3ZtcRM3+Rvk+zSOcGSwn3yDy4NYlv9bdUj/4H+aU1Qu1ZYojFM1Gmbe4HeYDOzRsJ5BhNrrV12h27JWkiRJ4F/Q=-----END RSA PRIVATE KEY----- Ps: RSA 是一种非对称的加密方式, 用公钥加密的文本, 要用私钥解密. 用私钥加密的文本, 要用公钥解密. 2. 安装 Navicat Premium安装后不要着急打开 Navicat, 先进到 /Applications/Navicat Premium.app/Contents/Resources 目录, 将rpk文件内容, 换为上面我们自己的公钥. 然后断网, 手动激活 , 输入序列号NAVH-T4PX-WT8W-QBL5 现在会拿到 请求码, 用私钥解密后, 会得到 12345&#123; "K" : "NAVHT4PXWT8WQBL5", "P" : "Mac 10.13", "DI" : "ODQ2Yjg2ZDBjMTEzMjhh"&#125; “K”代表激活密钥 “DI”代表设备码 要根据请求码, 拼装自己的激活码 {&quot;K&quot;:&quot;NAVHT4PXWT8WQBL5&quot;, &quot;N&quot;:&quot;Selfimpr&quot;, &quot;O&quot;:&quot;yuchen.pro&quot;, &quot;DI&quot;:&quot;ODQ2Yjg2ZDBjMTEzMjhh&quot;, &quot;T&quot;:1516280990} ​ 激活码的”K”和”DI”必须和请求码一致. ​ “N”代表名称，填写任意字符; ​ “O”代表组织，填写任意字符; ​ “T”代表注册时间，必须是UNIX时间格式的整数形式; *注意: 上面的激活码, 多一个空格, 都不行* 用私钥加密激活码, 粘到 Navicat中, 就可激活了 附: RSA在线加密解密工具 http://tool.chacuo.net/cryptrsapubkey]]></content>
      <categories>
        <category>ToolsCrack</category>
      </categories>
      <tags>
        <tag>Edraw</tag>
        <tag>ToolsCrack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程测试mysql数据库3306端口报错]]></title>
    <url>%2F2018%2F06%2F26%2Fnode%2Fdatabase%2Fnode-mysql_01%2F</url>
    <content type="text"><![CDATA[远程测试mysql数据库3306端口报错 错误现象：12345[root@localhost ~]# telnet 192.168.10.130 3306Trying 192.168.10.130...Connected to 192.168.10.130.Escape character is '^]'.GHost '192.168.10.120' is not allowed to connect to this MySQL serverConnection closed by foreign host 解决方法：具体原因是权限问题，需要重新设置外部登陆用户权限12345mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;Query OK, 0 rows affected (0.01 sec)mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec)mysql&gt; exit]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS上一些软件的激活]]></title>
    <url>%2F2018%2F06%2F21%2Fnode%2Fnode-tools-crack%2F</url>
    <content type="text"><![CDATA[MacOS上一些软件的激活 DataGrip:选择License server License service address: http://xidea.online]]></content>
      <categories>
        <category>ToolsCrack</category>
      </categories>
      <tags>
        <tag>ToolsCrack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edraw for Mac 注册码]]></title>
    <url>%2F2018%2F06%2F21%2Fnode%2Fnode-edraw-sn%2F</url>
    <content type="text"><![CDATA[Edraw9.1 for Mac 注册码 注意： 请断网情况下激活！选择 手动激活 ！ 用户名：GUANTAO2008 产品密钥：0711-8621-3000-8217-5433]]></content>
      <categories>
        <category>ToolsCrack</category>
      </categories>
      <tags>
        <tag>Edraw</tag>
        <tag>ToolsCrack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 批量插入数据]]></title>
    <url>%2F2018%2F06%2F20%2Fnode%2Fdatabase%2Fnode-oracle_14%2F</url>
    <content type="text"><![CDATA[Oracle 批量插入数据 12345INSERT INTO table(column1, column2, ... column_n )SELECT expression1, expression2, ... expression_nFROM source_table[WHERE conditions];]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单点登录]]></title>
    <url>%2F2018%2F06%2F19%2Fnode%2Fnode-sso_1%2F</url>
    <content type="text"><![CDATA[单点登录的基本思路 登录状态保存（redis/mysql） 请求携带登录状态返回标识（token） filter验证token]]></content>
      <categories>
        <category>SSO</category>
      </categories>
      <tags>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Docker下安装的Redis]]></title>
    <url>%2F2018%2F05%2F27%2Fnode%2Fdatabase%2Fnode-redis_2%2F</url>
    <content type="text"><![CDATA[修改Redis的密码 因为Redis, 默认是没有配置文件的, 所以我们要先创建redis.conf 文件, 我用 docker exec -ti redis /bin/bash 命令进到Redis容器中, 惊奇的发现, 我竟没办法编辑文本. 原来的路走不通, 只有另辟蹊径了. 在Mac(宿主机)上创建redis.conf 文件(下文贴出了文件) 修改配置文件 #requirepass foobared, 去掉# 修改自己的密码 删除原来的容器 docker rm redis 创建新的容器 docker run --name redis -p 6379:6379 -d redis redis-server /data/redis.conf 从宿主机复制到容器中 docker cp redis.conf redis:/data/ 附:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425# Redis配置文件样例# Note on units: when memory size is needed, it is possible to specifiy# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.# Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程# 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.piddaemonize no# 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定pidfile /var/run/redis.pid# 指定Redis监听端口，默认端口为6379# 如果指定0端口，表示Redis不监听TCP连接port 6379# 绑定的主机地址# 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接# bind 127.0.0.1# Specify the path for the unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 755# 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 0# 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose# debug (很多信息, 对开发／测试比较有用)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel verbose# 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/nulllogfile stdout# To enable logging to the system logger, just set &apos;syslog-enabled&apos; to yes,# and optionally update the other syslog parameters to suit your needs.# syslog-enabled no# Specify the syslog identity.# syslog-ident redis# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.# syslog-facility local0# 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id# dbid是从0到‘databases’-1的数目databases 16################################ SNAPSHOTTING ################################## 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合# Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## 满足以下条件将会同步数据:# 900秒（15分钟）内有1个更改# 300秒（5分钟）内有10个更改# 60秒内有10000个更改# Note: 可以把所有“save”行注释掉，这样就取消同步操作了save 900 1save 300 10save 60 10000# 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes# 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb# 工作目录.# 指定本地数据库存放目录，文件名由上一个dbfilename配置项指定# # Also the Append Only File will be created inside this directory.# # 注意，这里只能指定一个目录，不能指定文件名dir ./################################# REPLICATION ################################## 主从复制。使用slaveof从 Redis服务器复制一个Redis实例。注意，该配置仅限于当前slave有效# so for example it is possible to configure the slave to save the DB with a# different interval, or to listen to another port, and so on.# 设置当本机为slav服务时，设置master服务的ip地址及端口，在Redis启动时，它会自动从master进行数据同步# slaveof &lt;masterip&gt; &lt;masterport&gt;# 当master服务设置了密码保护时，slav服务连接master的密码# 下文的“requirepass”配置项可以指定密码# masterauth &lt;master-password&gt;# When a slave lost the connection with the master, or when the replication# is still in progress, the slave can act in two different ways:## 1) if slave-serve-stale-data is set to &apos;yes&apos; (the default) the slave will# still reply to client requests, possibly with out of data data, or the# data set may just be empty if this is the first synchronization.## 2) if slave-serve-stale data is set to &apos;no&apos; the slave will reply with# an error &quot;SYNC with master in progress&quot; to all the kind of commands# but to INFO and SLAVEOF.#slave-serve-stale-data yes# Slaves send PINGs to server in a predefined interval. It&apos;s possible to change# this interval with the repl_ping_slave_period option. The default value is 10# seconds.## repl-ping-slave-period 10# The following option sets a timeout for both Bulk transfer I/O timeout and# master data or ping response timeout. The default value is 60 seconds.## It is important to make sure that this value is greater than the value# specified for repl-ping-slave-period otherwise a timeout will be detected# every time there is low traffic between the master and the slave.## repl-timeout 60################################## SECURITY #################################### Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.# 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过auth &lt;password&gt;命令提供密码，默认关闭requirepass 123456# Command renaming.## It is possilbe to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# of hard to guess so that it will be still available for internal-use# tools but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possilbe to completely kill a command renaming it into# an empty string:## rename-command CONFIG &quot;&quot;################################### LIMITS ##################################### 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，# 如果设置maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max Number of clients reached错误信息# maxclients 128# Don&apos;t use more memory than the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys with an# EXPIRE set. It will try to start freeing keys that are going to expire# in little time and preserve keys with a longer time to live.# Redis will also try to remove objects from free lists if possible.## If all this fails, Redis will start to reply with errors to commands# that will use more memory, like SET, LPUSH, and so on, and will continue# to reply to most read-only commands like GET.## WARNING: maxmemory can be a good idea mainly if you want to use Redis as a# &apos;state&apos; server or cache, not as a real DB. When Redis is used as a real# database the memory usage will grow over the weeks, it will be obvious if# it is going to use too much memory in the long run, and you&apos;ll have the time# to upgrade. With maxmemory after the limit is reached you&apos;ll start to get# errors for write operations, and this may even lead to DB inconsistency.# 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，# 当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。# Redis新的vm机制，会把Key存放内存，Value会存放在swap区# maxmemory &lt;bytes&gt;# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached? You can select among five behavior:# # volatile-lru -&gt; remove the key with an expire set using an LRU algorithm# allkeys-lru -&gt; remove any key accordingly to the LRU algorithm# volatile-random -&gt; remove a random key with an expire set# allkeys-&gt;random -&gt; remove a random key, any key# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)# noeviction -&gt; don&apos;t expire at all, just return an error on write operations# # Note: with all the kind of policies, Redis will return an error on write# operations, when there are not suitable keys for eviction.## At the date of writing this commands are: set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort## The default is:## maxmemory-policy volatile-lru# LRU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can select as well the sample# size to check. For instance for default Redis will check three keys and# pick the one that was used less recently, you can change the sample size# using the following configuration directive.## maxmemory-samples 3############################## APPEND ONLY MODE ################################ # Note that you can have both the async dumps and the append only file if you# like (you have to comment the &quot;save&quot; statements above to disable the dumps).# Still if append only mode is enabled Redis will load the data from the# log file at startup ignoring the dump.rdb file.# 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。# 因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no# IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append# log file in background when it gets too big.appendonly no# 指定更新日志文件名，默认为appendonly.aof# appendfilename appendonly.aof# The fsync() call tells the Operating System to actually write data on disk# instead to wait for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP.# 指定更新日志条件，共有3个可选值：# no:表示等操作系统进行数据缓存同步到磁盘（快）# always:表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）# everysec:表示每秒同步一次（折衷，默认值）appendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it&apos;s possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving the durability of Redis is# the same as &quot;appendfsync none&quot;, that in pratical terms means that it is# possible to lost up to 30 seconds of log in the worst scenario (with the# default Linux settings).# # If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as# &quot;no&quot; that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size will growth by the specified percentage.# # This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (or if no rewrite happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a precentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################## SLOW LOG #################################### The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).# # You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands.# The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000# There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 1024################################ VIRTUAL MEMORY ################################## WARNING! Virtual Memory is deprecated in Redis 2.4### The use of Virtual Memory is strongly discouraged.### WARNING! Virtual Memory is deprecated in Redis 2.4### The use of Virtual Memory is strongly discouraged.# Virtual Memory allows Redis to work with datasets bigger than the actual# amount of RAM needed to hold the whole dataset in memory.# In order to do so very used keys are taken in memory while the other keys# are swapped into a swap file, similarly to what operating systems do# with memory pages.# 指定是否启用虚拟内存机制，默认值为no，# VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中# 把vm-enabled设置为yes，根据需要设置好接下来的三个VM参数，就可以启动VM了# vm-enabled yes# This is the path of the Redis swap file. As you can guess, swap files# can&apos;t be shared by different Redis instances, so make sure to use a swap# file for every redis process you are running. Redis will complain if the# swap file is already in use.## Redis交换文件最好的存储是SSD（固态硬盘）# 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享# *** WARNING *** if you are using a shared hosting the default of putting# the swap file under /tmp is not secure. Create a dir with access granted# only to Redis user and configure Redis to create the swap file there.# vm-swap-file /tmp/redis.swap# With vm-max-memory 0 the system will swap everything it can. Not a good# default, just specify the max amount of RAM you can in bytes, but it&apos;s# better to leave some margin. For instance specify an amount of RAM# that&apos;s more or less between 60 and 80% of your free RAM.# 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多少，所有索引数据都是内存存储的（Redis的索引数据就是keys）# 也就是说当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0# vm-max-memory 0# Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的。# 建议如果存储很多小对象，page大小最后设置为32或64bytes；如果存储很大的对象，则可以使用更大的page，如果不确定，就使用默认值# vm-page-size 32# 设置swap文件中的page数量由于页表（一种表示页面空闲或使用的bitmap）是存放在内存中的，在磁盘上每8个pages将消耗1byte的内存# swap空间总容量为 vm-page-size * vm-pages## With the default of 32-bytes memory pages and 134217728 pages Redis will# use a 4 GB swap file, that will use 16 MB of RAM for the page table.## It&apos;s better to use the smallest acceptable value for your application,# but the default is large in order to work in most conditions.# vm-pages 134217728# Max number of VM I/O threads running at the same time.# This threads are used to read/write data from/to swap file, since they# also encode and decode objects from disk to memory or the reverse, a bigger# number of threads can help with big objects even if they can&apos;t help with# I/O itself as the physical device may not be able to couple with many# reads/writes operations at the same time.# 设置访问swap文件的I/O线程数，最后不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟，默认值为4# vm-max-threads 4############################### ADVANCED CONFIG ################################ Hashes are encoded in a special way (much more memory efficient) when they# have at max a given numer of elements, and the biggest element does not# exceed a given threshold. You can configure this limits with the following# configuration directives.# 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法# hash-max-zipmap-entries 512# hash-max-zipmap-value 64# Similarly to hashes, small lists are also encoded in a special way in order# to save a lot of space. The special representation is only used when# you are under the following limits:# list-max-ziplist-entries 512# list-max-ziplist-value 64# Sets have a special encoding in just one case: when a set is composed# of just strings that happens to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:# zset-max-ziplist-entries 128# zset-max-ziplist-value 64# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into an hash table# that is rhashing, the more rehashing &quot;steps&quot; are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.# # The default is to use this millisecond 10 times every second in order to# active rehashing the main dictionaries, freeing memory when possible.## If unsure:# use &quot;activerehashing no&quot; if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply form time to time# to queries with 2 milliseconds delay.# 指定是否激活重置哈希，默认为开启activerehashing yes################################## INCLUDES #################################### 指定包含其他的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各实例又拥有自己的特定配置文件# include /path/to/local.conf# include /path/to/other.conf]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 禁止缩放]]></title>
    <url>%2F2018%2F05%2F22%2Fnode%2Fnode-html_3%2F</url>
    <content type="text"><![CDATA[HTML 手机端显示禁止缩放 在HTML的HEAD中加入 1&lt;meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" name="viewport" /&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 安装与配置 Nginx]]></title>
    <url>%2F2018%2F05%2F22%2Fnode%2Fnode-nginx_2%2F</url>
    <content type="text"><![CDATA[MacOS 安装与配置 Nginx Nginx 安装brew install nginx Nginx 涉及到的路径 /usr/local/cellar/nginx/1.13.12 安装目录 /usr/local/etc/nginx 配置文件 /usr/local/var/log/nginx 日志文件 配置虚拟主机12345678910111213141516171819202122232425upstream www.yeslx.com &#123; server 127.0.0.1:8880;&#125;server &#123; listen 80; server_name 127.0.0.1 192.168.1.104 www.yeslx.com; charset utf-8; access_log /usr/local/var/log/nginx/access.log; error_log /usr/local/var/log/nginx/error.log; location / &#123; root /Users/smile/development/workspace/nginx/yslx_app; index index.php index.html index.htm; &#125; location ~ ^/(backstage)/ &#123; proxy_pass http://www.yeslx.com; proxy_set_header Host $host; &#125; location ~ ^/(proscenium)/ &#123; proxy_pass http://www.yeslx.com; proxy_set_header Host $host; &#125;&#125; Nginx 常用命令 nginx -t 测试配置是否正确 nginx -s reload 重新加载配置文件 nginx -s stop 立即停止服务 nginx -s quit 优雅的停止服务 nginx -s reopen 重新打开日志 Nginx 启动失败12345SmiledeMacBook-Pro:~ smile$ nginx nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)SmiledeMacBook-Pro:~ smile$ sudo nginxPassword:SmiledeMacBook-Pro:~ smile$]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Image To Base64]]></title>
    <url>%2F2018%2F05%2F22%2Fnode%2Fjavascript%2Fnode-javascript_17%2F</url>
    <content type="text"><![CDATA[JavaScript Image To Base64 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="file" name="file" id="file" value="" /&gt; &lt;input type="hidden" name="val" id="val" value="" /&gt; &lt;input type="button" name="button" id="button" value="Click..." /&gt; &lt;script type="text/javascript"&gt; document.getElementById("file").onchange = function() &#123; var reader = new FileReader(); var file = document.getElementById("file"); reader.readAsDataURL(file.files[0]); reader.onload = function() &#123; var base64=reader.result; document.getElementById("val").value = base64; console.log(base64); &#125; &#125; document.getElementById("button").onclick = function() &#123; alert(document.getElementById("val").value); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64 转 图片]]></title>
    <url>%2F2018%2F05%2F21%2Fnode%2Fjava%2Fnode-j2se_03%2F</url>
    <content type="text"><![CDATA[Base64 转 图片 少废话, 直接看代码 12345678910111213141516171819202122232425public static boolean base64ToImage(String base64, String url) &#123; if (base64 == null || "".equals(base64)) &#123; // 图像数据为空 return false; &#125; BASE64Decoder decoder = new BASE64Decoder(); try &#123; // Base64解码 byte[] b = decoder.decodeBuffer(base64); for (int i = 0; i &lt; b.length; ++i) &#123; if (b[i] &lt; 0) &#123;// 调整异常数据 b[i] += 256; &#125; &#125; // 生成jpeg图片 String imgFilePath = url;// 新生成的图片 OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; 注意: 前端传过来的数据中, 可能会携带图片的头信息data:image/jpeg;base64, ,要记得删掉]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 中生成二维码]]></title>
    <url>%2F2018%2F05%2F07%2Farticle%2FSpringBoot%2Farticle-spring-boot_12%2F</url>
    <content type="text"><![CDATA[在Web应用中, 生成二维码 pom.xml中引入jar包依赖123456&lt;!-- QrCode --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;qrcode-utils&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt; 生成二维码12345678910111213141516171819202122232425262728293031package pro.yuchen.demo.spring_demo.web;import com.github.binarywang.utils.qrcode.QrcodeUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.ByteArrayInputStream;@RestControllerpublic class QrCodeController &#123; @RequestMapping("/qrcode/&#123;id&#125;") public void image(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 生成二维码图片 byte[] bytes = QrcodeUtils.createQrcode("嘿嘿....", 800, null); BufferedImage image = ImageIO.read(new ByteArrayInputStream(bytes)); //设置浏览器以图片格式输出 response.setContentType("image/jpeg"); //设置响应头控制浏览器不要缓存 response.setDateHeader("expries", -1); response.setHeader("Cache-Control", "no-cache"); response.setHeader("Pragma", "no-cache"); //将图片写给浏览器 ImageIO.write(image, "jpg", response.getOutputStream()); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>QrCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 发送Email]]></title>
    <url>%2F2018%2F04%2F22%2Farticle%2FSpringBoot%2Farticle-spring-boot_11%2F</url>
    <content type="text"><![CDATA[使用 SpringBoot 发送邮件 闲言少叙, 直接上代码 首先引入pom 依赖 12345&lt;!-- Mail --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 然后就是功能代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package pro.yuchen.demo.spring_demo.mail;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;@Componentpublic class MailService &#123; private final Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender sender; @Value("$&#123;config.mail.fromMail.addr&#125;") private String from; /** * 发送文本邮 * @param to 要发送的邮箱地址 * @param subject e-mail主题 * @param content e-mail内容 */ public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; sender.send(message); log.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; log.error("发送简单邮件时发生异常！", e); &#125; &#125; /** * 发送html邮件 * @param to 要发送的邮箱地址 * @param subject e-mail主题 * @param content e-mail内容 */ public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = sender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); sender.send(message); log.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; log.error("发送html邮件时发生异常！", e); &#125; &#125; /** * 发送带附件的邮件 * @param to 要发送的邮箱地址 * @param subject e-mail主题 * @param content e-mail内容 * @param filePath 附件路径 */ public void sendAttachmentsMail(String to, String subject, String content, String filePath) &#123; MimeMessage message = sender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); sender.send(message); log.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; log.error("发送带附件的邮件时发生异常！", e); &#125; &#125; /** * 发送正文中有静态资源（图片）的邮件 * @param to 要发送的邮箱地址 * @param subject e-mail主题 * @param content e-mail内容 * @param rscPath 静态图片路径 * @param rscId 静态图片编号 */ public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId) &#123; MimeMessage message = sender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); sender.send(message); log.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; log.error("发送嵌入静态资源的邮件时发生异常！", e); &#125; &#125;&#125; 测试: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package pro.yuchen.demo.spring_demo.mail;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import pro.yuchen.demo.spring_demo.Application;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;Application.class&#125;)public class MailServiceTest &#123; @Autowired private MailService mailService; @Test public void testSimpleMail() throws Exception &#123; mailService.sendSimpleMail("yuchen352416@gmail.com", "Test", "hehehehehehehheheheh"); &#125; @Test public void testHtmlMail() throws Exception &#123; StringBuffer content = new StringBuffer(); content.append("&lt;html&gt;").append("\n"); content.append(" &lt;body&gt;").append("\n"); content.append(" &lt;h3&gt;Hello Mail....&lt;/h3&gt;").append("\n"); content.append(" &lt;/body&gt;").append("\n"); content.append("&lt;/html&gt;").append("\n"); mailService.sendHtmlMail("yuchen352416@gmail.com", "HTML Test", content.toString()); &#125; @Test public void testAttachmentsMail() &#123; StringBuffer content = new StringBuffer(); content.append("&lt;html&gt;").append("\n"); content.append(" &lt;body&gt;").append("\n"); content.append(" &lt;h3&gt;Hello Mail....&lt;/h3&gt;").append("\n"); content.append(" &lt;/body&gt;").append("\n"); content.append("&lt;/html&gt;").append("\n"); String filepath = "/Users/smile/Documents/notes/Journal.md"; mailService.sendAttachmentsMail("yuchen352416@gmail.com", "File Test", content.toString(), filepath); &#125; @Test public void testInlineResourceMail() &#123; String rscId = "neo006"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "/Users/smile/Pictures/Wechat.jpeg"; mailService.sendInlineResourceMail("yuchen352416@gmail.com", "File Test", content, imgPath, rscId); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 安装与配置]]></title>
    <url>%2F2018%2F04%2F17%2Fnode%2Fnode-nginx_1%2F</url>
    <content type="text"><![CDATA[Nginx 安装与配置 Nginx 安装yum install nginx -y 查看 Nginx 安装路径ps -ef | grep nginx 配置文件 /etc/nginx/nginx.conf /etc/nginx/conf.d/*.conf 配置默认根目录跳转8083端口12345678910server &#123; listen 80; server_name localhost; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8083; &#125;&#125; 配置指定路径跳转8090端口1234567891011121314upstream wechat &#123; server 127.0.0.1:8090; keepalive 2000;&#125;server &#123; listen 80; server_name localhost; location /wechat/ &#123; proxy_pass http://wechat/; proxy_set_header Host $host:$server_port; &#125;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 安装 MySQL容器]]></title>
    <url>%2F2018%2F03%2F31%2Fnode%2Flinux%2Fnode-docker_02%2F</url>
    <content type="text"><![CDATA[Docker 安装 MySQL容器 1. 下载 MySQL镜像 docker pull mysql/mysql-server 2. 启动容器 docker run -p 3306:3306 --name=mysql -d mysql/mysql-server 3. 查看MySQL默认密码 docker logs mysql 4. 登录后修改密码 set password = password(&#39;123456&#39;); 5. 解决一下远程登录的问题 update user set host = &#39;%&#39; where user = &#39;root&#39;;]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot RabbitMQ]]></title>
    <url>%2F2018%2F03%2F22%2Farticle%2FSpringBoot%2Farticle-spring-boot_10%2F</url>
    <content type="text"><![CDATA[SpringBoot 中使用 消息队列 RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。 1. 安装RabbitMQ1.1. 下载 RabbitMQ 的Docker镜像docker pull frodenas/rabbitmq 1.2. 启动镜像docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_USERNAME=admin -e RABBITMQ_PASSWORD=admin frodenas/rabbitmq 1.3. 其他详细配置 https://hub.docker.com/r/frodenas/rabbitmq/ 2. 添加pom.xml依赖, 以及基本配置2.1. 添加pom.xml依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 application.yml 基本配置123456spring: rabbitmq: host: 127.0.0.1 port: 5672 username: admin password: admin 3. 交换机(Exchange)3.1. Topic ExchangeTopic Exchange 转发消息主要是根据通配符。 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。 在这种交换机模式下： 路由键(routing_key)必须是一串字符，用句号（.） 隔开，比如说 message.user.jack，或者 message.user.jude 等。 路由模式下的消息匹配: 如果ServerA只想接收发给jude的消息, 就可以匹配 message.user.jude, 而ServerB想要接收发给所有用户的消息, 就可以匹配 message.user.*, 现在有ServerC 要接收所有消息, 就可以匹配message.# topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符: *表示一个词. #表示零个或多个词. 3.2. Fanout ExchangeFanout Exchange 消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列，如果配置了routing_key会被忽略。 4. SpringBoot中使用RabbitMQ4.1. 使用 Topic(主题) TopicRabbitConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package pro.yuchen.demo.spring_demo.mq.topic;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class TopicRabbitConfig &#123; public final static String exchange = "messages"; public final static String mysql = "message.disk.mysql"; public final static String hbase = "message.disk.hbase"; @Bean public Queue queueMySQL() &#123; return new Queue("mysql"); &#125; @Bean public Queue queueHBase() &#123; return new Queue("hbase"); &#125; @Bean public Queue queueDisk() &#123; return new Queue("disk"); &#125; @Bean TopicExchange exchange() &#123; return new TopicExchange(TopicRabbitConfig.exchange, true, true); &#125; @Bean Binding bindingExchangeMySQL(Queue queueMySQL, TopicExchange exchange) &#123; return BindingBuilder.bind(queueMySQL).to(exchange).with(TopicRabbitConfig.mysql); &#125; @Bean Binding bindingExchangeHBase(Queue queueHBase, TopicExchange exchange) &#123; return BindingBuilder.bind(queueHBase).to(exchange).with(TopicRabbitConfig.hbase); &#125; @Bean Binding bindingExchangeDisk(Queue queueDisk, TopicExchange exchange) &#123; return BindingBuilder.bind(queueDisk).to(exchange).with("message.disk.#"); &#125;&#125; TopicSender 12345678910111213141516171819202122package pro.yuchen.demo.spring_demo.mq.topic;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class TopicSender &#123; @Autowired private AmqpTemplate rabbitTemplate; /** * 发送消息 * @param routingKey 路由key * @param context 消息内容 */ public void send(String routingKey, Object context) &#123; System.out.println("Sender : " + context); this.rabbitTemplate.convertAndSend(TopicRabbitConfig.exchange, routingKey, context); &#125;&#125; TopicReceiverQueuesDisk 123456789101112131415package pro.yuchen.demo.spring_demo.mq.topic;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = "disk")public class TopicReceiverQueuesDisk &#123; @RabbitHandler public void process(String message) &#123; System.out.println("Topic Disk : " + message); &#125;&#125; TopicReceiverQueuesHBase 123456789101112131415package pro.yuchen.demo.spring_demo.mq.topic;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = "hbase")public class TopicReceiverQueuesHBase &#123; @RabbitHandler public void process(String message) &#123; System.out.println("Topic HBase : " + message); &#125;&#125; TopicReceiverQueuesMySQL123456789101112131415package pro.yuchen.demo.spring_demo.mq.topic;import org.springframework.amqp.rabbit.annotation.RabbitHandler;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Component@RabbitListener(queues = "mysql")public class TopicReceiverQueuesMySQL &#123; @RabbitHandler public void process(String message) &#123; System.out.println("Topic MySQL : " + message); &#125;&#125; 一个队列, 可以绑定多个 Routing Key , 在开发过程中, 若修改了匹配关系(Routing Key), Spring 默认是增加一条Routing Key, 原来的Routing Key还会被保留. 所以这里一定要谨慎 4.2. 使用 Fanout(广播)]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProtoBuf 学习(一)]]></title>
    <url>%2F2018%2F03%2F20%2Fnode%2Fnode-protobuf_1%2F</url>
    <content type="text"><![CDATA[ProtoBuf 环境的安装与HelloWord 1. 安装 ProtoBuf brew install protobuf@2.5.0 2. 新建 person.proto 文件1234567891011121314151617181920212223242526272829syntax = "proto2";package tutorial;option java_package = "pro.yuchen.demo.spring_demo.proto";option java_outer_classname = "AddressBookProtos";message Person &#123; required string name = 1; // 非空属性 required int32 id = 2; // 非空属性 optional string email = 3; // 可空属性 enum PhoneType &#123; // 枚举类型 MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; // 子类(可多个, JSON表现为数组形式) required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 3. 生成 Java源文件protoc --java_out . person.proto 4. 导入pom.xml依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.googlecode.protobuf-java-format&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java-format&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ps: 将刚刚根据.proto生成的 java文件, 导入项目中 5. 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package pro.yuchen.demo.spring_demo.proto;import com.google.protobuf.ByteString;import com.google.protobuf.Descriptors;import com.google.protobuf.Descriptors.FieldDescriptor;import com.google.protobuf.Message;import com.googlecode.protobuf.format.JsonFormat;import org.junit.Test;import pro.yuchen.demo.spring_demo.proto.Protos.Person;import java.util.Iterator;import java.util.List;import java.util.Map;public class ProtoBufTest &#123; @Test public void testProtoBuf() throws Exception &#123; Person person = Person.newBuilder() .setId(1) .setName("Tom") .setEmail("yuchen352416@163.com") .addPhones(Person.PhoneNumber.newBuilder() .setNumber("18733775865") .setType(Person.PhoneType.MOBILE)) .build(); // ProtoBuf -&gt; JSON String jsonFormat = JsonFormat.printToString(person); System.out.println(jsonFormat); // JSON -&gt; ProtoBuf String json = "&#123;\"name\": \"Tom\", \"id\": 1, \"email\": \"yuchen352416@163.com\", \"phones\": [&#123;\"number\": \"18733775865\", \"type\": 1 &#125;, &#123;\"number\": \"13463170232\", \"type\": 0 &#125; ] &#125;"; Message.Builder message = Person.newBuilder(); JsonFormat.merge(json, message); System.out.println(message.build()); byte[] bytes = person.toByteArray(); // 序列化 Person result = Person.parseFrom(bytes); // 反序列化 // 遍历输出 for (Iterator&lt;Map.Entry&lt;FieldDescriptor, Object&gt;&gt; iter = result.getAllFields().entrySet().iterator(); iter.hasNext();) &#123; Map.Entry&lt;FieldDescriptor, Object&gt; field = iter.next(); System.out.println("Number: " + field.getKey().getNumber()); System.out.println("Type: " + field.getKey().getType()); System.out.println("Name: " + field.getKey().getName()); System.out.println("FullName: " + field.getKey().getFullName()); System.out.println("FileName: " + field.getKey().getFile().getName()); printFieldValue(field); System.out.println("-------------------------------------------"); System.out.println(); &#125; &#125; private void printFieldValue(Map.Entry&lt;FieldDescriptor, Object&gt; field) &#123; switch (field.getKey().getType())&#123; case INT32: case INT64: case SINT32: case SINT64: case SFIXED32: case SFIXED64: case FLOAT: case DOUBLE: case BOOL: // Good old toString() does what we want for these types. System.out.println("Value: " + field.getValue().toString()); break; case UINT32: case FIXED32: System.out.println("Value: " + (Integer) field.getValue()); break; case UINT64: case FIXED64: System.out.println("Value: " + (Long) field.getValue()); break; case STRING: &#123; System.out.println("Value: " + (String) field.getValue()); break; &#125; case BYTES: &#123; System.out.println("Value: " + (ByteString) field.getValue()); break; &#125; case ENUM: &#123; System.out.println("Value: " + ((Descriptors.EnumValueDescriptor) field.getValue()).getName()); break; &#125; case MESSAGE: case GROUP: System.out.println("Size: " + ((List&lt;?&gt;) field.getValue()).size()); System.out.println("Value: ["); List&lt;?&gt; list = (List&lt;?&gt;) field.getValue(); for (Object o : list) &#123; Message message = (Message) o; for (Iterator&lt;Map.Entry&lt;FieldDescriptor, Object&gt;&gt; iters = message.getAllFields().entrySet().iterator(); iters.hasNext();) &#123; Map.Entry&lt;FieldDescriptor, Object&gt; iter = iters.next(); System.out.println("\t-----Number: " + iter.getKey().getNumber()); System.out.println("\t-----Type: " + iter.getKey().getType()); System.out.println("\t-----Name: " + iter.getKey().getName()); System.out.println("\t-----FullName: " + iter.getKey().getFullName()); System.out.println("\t-----FileName: " + iter.getKey().getFile().getName()); System.out.print("\t-----"); printFieldValue(iter); System.out.println("\t--------------------------------------------"); &#125; System.out.println(); &#125; System.out.println("]"); break; &#125; &#125;&#125; 输出结果: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123;&quot;name&quot;: &quot;Tom&quot;,&quot;id&quot;: 1,&quot;email&quot;: &quot;yuchen352416@163.com&quot;,&quot;phones&quot;: [&#123;&quot;number&quot;: &quot;18733775865&quot;,&quot;type&quot;: &quot;MOBILE&quot;&#125;]&#125;name: &quot;Tom&quot;id: 1email: &quot;yuchen352416@163.com&quot;phones &#123; number: &quot;18733775865&quot; type: HOME&#125;phones &#123; number: &quot;13463170232&quot; type: MOBILE&#125;Number: 1Type: STRINGName: nameFullName: Person.nameFileName: person.protoValue: Tom-------------------------------------------Number: 2Type: INT32Name: idFullName: Person.idFileName: person.protoValue: 1-------------------------------------------Number: 3Type: STRINGName: emailFullName: Person.emailFileName: person.protoValue: yuchen352416@163.com-------------------------------------------Number: 4Type: MESSAGEName: phonesFullName: Person.phonesFileName: person.protoSize: 1Value: [ -----Number: 1 -----Type: STRING -----Name: number -----FullName: Person.PhoneNumber.number -----FileName: person.proto -----Value: 18733775865 -------------------------------------------- -----Number: 2 -----Type: ENUM -----Name: type -----FullName: Person.PhoneNumber.type -----FileName: person.proto -----Value: MOBILE --------------------------------------------]-------------------------------------------]]></content>
      <categories>
        <category>ProtoBuf</category>
      </categories>
      <tags>
        <tag>ProtoBuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Hibernate]]></title>
    <url>%2F2018%2F03%2F20%2Farticle%2FSpringBoot%2Farticle-spring-boot_09%2F</url>
    <content type="text"><![CDATA[SpringBoot 中使用 Hibernate操作数据库 1. 添加pom.xml依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2. 修改配置文件application.yml123456789101112spring: datasource: # 数据库连接参数 driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/base_db?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root jpa: database: MYSQL hibernate: ddl-auto: update dialect: org.hibernate.dialect.MySQL5InnoDBDialect show-sql: true 3. 新建表1234567891011121314USE base_db;CREATE TABLE BLOG ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(30) NOT NULL, content VARCHAR(4000))ENGINE=InnoDB DEFAULT CHARSET=utf8;ALTER TABLE BLOG COMMENT = '博客表';CREATE TABLE COMMENT ( id BIGINT PRIMARY KEY AUTO_INCREMENT, content VARCHAR(4000), blog_id INT NOT NULL)ENGINE=InnoDB DEFAULT CHARSET=utf8;ALTER TABLE COMMENT COMMENT = '评论表'; 4. 添加Entity实体4.1. Blog 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package pro.yuchen.demo.spring_demo.entity;import org.hibernate.annotations.Fetch;import org.hibernate.annotations.FetchMode;import java.io.Serializable;import java.util.List;import javax.persistence.*;@Entity@Table(name="blog")public class Blog implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Integer id; @Column private String title; @Column private String content; @OneToMany(targetEntity=Comment.class,cascade=CascadeType.ALL) @Fetch(FetchMode.JOIN) //updatable=false很关键，如果没有它，在级联删除的时候就会报错(反转的问题) @JoinColumn(name="blog_id",updatable=false) private List&lt;Comment&gt; comments; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public List&lt;Comment&gt; getComments() &#123; return comments; &#125; public void setComments(List&lt;Comment&gt; comments) &#123; this.comments = comments; &#125;&#125; 4.2. Comment 类1234567891011121314151617181920212223242526272829303132333435363738394041424344package pro.yuchen.demo.spring_demo.entity;import javax.persistence.*;@Entity@Table(name="comment")public class Comment &#123; @Id @GeneratedValue(strategy= GenerationType.AUTO) private Integer id; @Column private String content; //多对一，@JoinColumn与@column类似，指定映射的数据库字段 @ManyToOne(targetEntity = Blog.class) @JoinColumn(name="blog_id",updatable=false) private Blog blog; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Blog getBlog() &#123; return blog; &#125; public void setBlog(Blog blog) &#123; this.blog = blog; &#125;&#125; 附: “一对多”, “多对一” 关系, 是针对两个实体说的 5. 新建 JPA操作类5.1. Blog 操作类12345678package pro.yuchen.demo.spring_demo.dao;import org.springframework.data.jpa.repository.JpaRepository;import pro.yuchen.demo.spring_demo.entity.Blog;public interface BlogRepository extends JpaRepository&lt;Blog, Integer&gt; &#123;&#125; 5.2.Comment 操作类12345678package pro.yuchen.demo.spring_demo.dao;import org.springframework.data.jpa.repository.JpaRepository;import pro.yuchen.demo.spring_demo.entity.Comment;public interface CommentRepository extends JpaRepository&lt;Comment, Integer&gt; &#123;&#125; 6. 测试用例6.1. 测试 BlogRepository12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package pro.yuchen.demo.spring_demo.dao;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import pro.yuchen.demo.spring_demo.Application;import pro.yuchen.demo.spring_demo.entity.Blog;import pro.yuchen.demo.spring_demo.entity.Comment;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class, Application.class&#125;)@WebAppConfigurationpublic class BlogRepositoryTest &#123; @Autowired private BlogRepository repository; @Test public void insert() throws Exception &#123; Blog blog = new Blog(); String title = "TEST......."; blog.setTitle(title); blog.setContent("jjjjkkkkjjsfjseoijqksahbfgoyhujikldfghjklsdfgesdrtfgzxrdcfvgbnazesxdcfvgbhnjklaWzesxdcfvgbhjklazsdfghjkazesxdcfghj"); repository.save(blog); &#125; @Test public void delete() &#123; repository.delete(10); &#125; @Test public void update() &#123; Blog blog = repository.findOne(12); blog.setTitle("花一样的人生...."); repository.save(blog); System.out.println(repository.findOne(12).getTitle()); &#125; @Test public void findOne() &#123; Blog result = repository.findOne(45); System.out.println(result.getTitle()); for (Comment comment:result.getComments()) &#123; System.out.println(comment.getContent()); &#125; &#125; @Test public void findAllByPage() &#123; Sort sort = new Sort(Sort.Direction.DESC, "title"); Pageable pageable = new PageRequest(1,10, sort); Page&lt;Blog&gt; list = repository.findAll(pageable); for (Blog blog : list) &#123; System.out.println(blog.getTitle()); &#125; &#125;&#125; 6.2 测试 CommentRepository123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package pro.yuchen.demo.spring_demo.dao;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import pro.yuchen.demo.spring_demo.Application;import pro.yuchen.demo.spring_demo.entity.Blog;import pro.yuchen.demo.spring_demo.entity.Comment;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;Application.class&#125;)public class CommentRepositoryTest &#123; @Autowired private CommentRepository repository; @Test public void insert() &#123; Blog blog = new Blog(); for (int i = 30; i &lt; 100; i++) &#123; blog.setId(i); for(int j = 0; j &lt; 10; j++) &#123; Comment comment = new Comment(); comment.setBlog(blog); comment.setContent("评论...." + j); repository.save(comment); &#125; &#125; &#125; @Test public void delete() &#123; repository.delete(23); &#125; @Test public void update() &#123; Comment comment = repository.findOne(10); comment.setContent("lll"); repository.save(comment); &#125; @Test public void findOne() &#123; Comment comment = repository.findOne(10); System.out.println(comment.getContent()); &#125; @Test public void findAllByPage() &#123; Sort sort = new Sort(Sort.Direction.ASC, "blog_id", "id"); Pageable pageable = new PageRequest(23,10, sort); Page&lt;Comment&gt; list = repository.findAll(pageable); for (Comment comment : list) &#123; System.out.println(comment.getContent() + " " + comment.getId()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot AOP]]></title>
    <url>%2F2018%2F03%2F19%2Farticle%2FSpringBoot%2Farticle-spring-boot_08%2F</url>
    <content type="text"><![CDATA[SpringBoot 中使用 AOP 1. 添加pom.xml依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 2. 添加切片类1234567891011121314151617181920212223242526272829303132package pro.yuchen.demo.spring_demo.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;/** * 通用AOP */@Aspect@Componentpublic class GlobalAspect &#123; public static final String GET = "execution(* pro.yuchen.demo.spring_demo.mapper.*.get(..))"; @Pointcut(GET) private void get() &#123; &#125; // 声明环绕通知 @Around("get()") public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; long startTime = System.currentTimeMillis(); Object o = pjp.proceed(); MethodSignature signature = (MethodSignature) pjp.getSignature(); String methodName = signature.getDeclaringTypeName() + "." + signature.getName(); long endTime = System.currentTimeMillis(); System.out.println(endTime - startTime); return o; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot MyBatis]]></title>
    <url>%2F2018%2F03%2F18%2Farticle%2FSpringBoot%2Farticle-spring-boot_07%2F</url>
    <content type="text"><![CDATA[SpringBoot 与MyBatis 整合 1. 添加pom.xml依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 2. 修改配置文件123456spring: datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/base_db?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root 3. 新建实体以及Mapper类(注解方式)3.1. 实体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package pro.yuchen.demo.spring_demo.entity;import java.io.Serializable;import java.util.Date;public class Visitor implements Serializable &#123; /** * 主键 */ private Integer id; /** * 名字 */ private String name; /** * 邮箱地址 */ private String email; /** * 状态标识 */ private Integer status; /** * 创建时间 */ private Date createTime; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125;&#125; 3.2. Mapper 类12345678910111213141516171819202122232425262728293031package pro.yuchen.demo.spring_demo.mapper;import org.apache.ibatis.annotations.*;import pro.yuchen.demo.spring_demo.entity.Visitor;import java.util.List;public interface VisitorMapper &#123; @Insert("INSERT INTO visitor(name, email, status, create_time) VALUES(#&#123;name&#125;, #&#123;email&#125;, #&#123;status&#125;, #&#123;createTime&#125;)") void insert(Visitor visitor); @Delete("DELETE FROM visitor WHERE id=#&#123;id&#125;") void delete(Integer id); @Update("UPDATE visitor SET name=#&#123;name&#125;, email=#&#123;email&#125;, status=#&#123;status&#125;, create_time=#&#123;createTime&#125; WHERE id=#&#123;id&#125;") void update(Visitor visitor); @Select("SELECT * FROM visitor") @Results(&#123; @Result(property = "createTime", column = "create_time") &#125;) List&lt;Visitor&gt; getAll(); // 注意这里的方法, 是不可以重载的 @Select("SELECT * FROM visitor WHERE id=#&#123;id&#125;") @Results(&#123; @Result(property = "createTime", column = "create_time") &#125;) Visitor get(Integer id);&#125; 3.3. 测试用例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pro.yuchen.demo.spring_demo.mapper;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import pro.yuchen.demo.spring_demo.Application;import pro.yuchen.demo.spring_demo.entity.Visitor;import java.util.Date;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class, Application.class&#125;)public class VisitorMapperTest &#123; @Autowired private VisitorMapper mapper; @Test public void insert() &#123; Visitor visitor = new Visitor(); visitor.setCreateTime(new Date()); visitor.setName("Ws"); visitor.setEmail("ws@163.com"); visitor.setStatus(1); mapper.insert(visitor); &#125; @Test public void delete() &#123; mapper.delete(8); &#125; @Test public void update() &#123; Visitor visitor = mapper.get(2); System.out.println(visitor.getName()); visitor.setName("Mr.Li"); mapper.update(visitor); &#125; @Test public void get() &#123; List&lt;Visitor&gt; list = mapper.getAll(); for (Visitor visitor : list) &#123; System.out.println(visitor.getName()); &#125; Visitor visitor = mapper.get(2); System.out.println(visitor.getName()); &#125;&#125; 4. 新建实体以及mapper.xml(xml方式)4.1. 修改application.yml配置文件1234# mybatis 配置文件路径mybatis: config-locations: classpath:mybatis/mybatis-config.xml mapper-locations: classpath:mybatis/mapper/*.xml 4.2. 实体12345678910111213141516171819202122232425262728293031323334353637383940package pro.yuchen.demo.spring_demo.entity;public class User &#123; private Integer id; private String name; private Integer age; private String city; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125;&#125; 4.3. 新建Mapper接口123456789101112131415161718package pro.yuchen.demo.spring_demo.mapper;import pro.yuchen.demo.spring_demo.entity.User;import java.util.List;public interface UserMapper &#123; void insert(User user); void delete(Integer id); void update(User user); List&lt;User&gt; getAll(); // 注意这里的方法, 是不可以重载的 User get(Integer id);&#125; 4.4. 新建 user-mapper.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="pro.yuchen.demo.spring_demo.mapper.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="pro.yuchen.demo.spring_demo.entity.User" &gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="name" property="name" jdbcType="VARCHAR" /&gt; &lt;result column="age" property="age" jdbcType="BIGINT" /&gt; &lt;result column="city" property="city" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, name, age, city &lt;/sql&gt; &lt;insert id="insert" parameterType="pro.yuchen.demo.spring_demo.entity.User"&gt; INSERT INTO user(name, age, city) values(#&#123;name&#125;, #&#123;age&#125;, #&#123;city&#125;) &lt;/insert&gt; &lt;delete id="delete" parameterType="Integer"&gt; DELETE FROM user WHERE id =#&#123;id&#125; &lt;/delete&gt; &lt;update id="update" parameterType="pro.yuchen.demo.spring_demo.entity.User"&gt; UPDATE user SET &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="age &gt;= 0"&gt;age = #&#123;age&#125;,&lt;/if&gt; city = #&#123;city&#125; WHERE id = #&#123;id&#125; &lt;/update&gt; &lt;select id="getAll" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM user &lt;/select&gt; &lt;select id="get" parameterType="Integer" resultMap="BaseResultMap" &gt; SELECT &lt;include refid="Base_Column_List" /&gt; FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 4.5. 测试用例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pro.yuchen.demo.spring_demo.mapper;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import pro.yuchen.demo.spring_demo.Application;import pro.yuchen.demo.spring_demo.entity.User;import pro.yuchen.demo.spring_demo.entity.Visitor;import java.util.Date;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class, Application.class&#125;)public class UserMapperTest &#123; @Autowired private UserMapper mapper; @Test public void insert() &#123; User user = new User(); user.setAge(20); user.setName("mmw"); user.setCity("dd"); mapper.insert(user); &#125; @Test public void delete() &#123; mapper.delete(1); &#125; @Test public void update() &#123; User user = mapper.get(2); System.out.println(user.getName()); user.setName("Mr.Li"); mapper.update(user); &#125; @Test public void get() &#123; List&lt;User&gt; list = mapper.getAll(); for (User user : list) &#123; System.out.println(user.getName()); &#125; User user = mapper.get(2); System.out.println(user.getName()); &#125;&#125; 5. 面试中遇到过的问题5.1 resultType 与 resultMap 的区别用select查询时返回值的类型可以为resultType和resultMap两种类型. resultType表示返回类型，映射成我们的model对象中的实体， resultMap需要提前定义好数据库db和model实体类对应关系，然后在引用定义好的外部resultMap resultMap和resultType是不能同时存在的 5.2 # 与 $ 的区别动态 SQL 是 mybatis 的强大特性之一，也是它优于其他 ORM 框架的一个重要原因。mybatis 在对 sql 语句进行预编译之前，会对 sql 进行动态解析，解析为一个 BoundSql 对象，也是在此处对动态 SQL 进行处理的。 在动态 SQL 解析阶段， #{ } 和 ${ } 会有不同的表现： #{ } 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符。 例如，sqlMap 中如下的 sql 语句 1select * from user where name = #&#123;name&#125;; 解析为： 1select * from user where name = ?; 一个 #{ } 被解析为一个参数占位符 ? 。 ${ } 仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换 例如，sqlMap 中如下的 sql 1select * from user where name = &apos;$&#123;name&#125;&apos;; 当我们传递的参数为 “ruhua” 时，上述 sql 的解析为： 1select * from user where name = &quot;ruhua&quot;; 预编译之前的 SQL 语句已经不包含变量 name 了。 附: JDBC Type Java Type CHAR String VARCHAR String LONGVARCHAR String NUMERIC java.math.BigDecimal DECIMAL java.math.BigDecimal BIT boolean BOOLEAN boolean TINYINT byte SMALLINT short INTEGER int BIGINT long REAL float FLOAT double DOUBLE double BINARY byte[] VARBINARY byte[] LONGVARBINARY byte[] DATE java.sql.Date TIME java.sql.Time TIMESTAMP java.sql.Timestamp CLOB Clob BLOB Blob ARRAY Array DISTINCT mapping of underlying type STRUCT Struct REF Ref DATALINK java.net.URL JAVA_OBJECT underlying Java class]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot IDEA中实现热部署]]></title>
    <url>%2F2018%2F03%2F17%2Farticle%2FSpringBoot%2Farticle-spring-boot_06%2F</url>
    <content type="text"><![CDATA[SpringBoot 在IDEA中实现热部署 1. 添加pom.xml依赖123456&lt;!-- 热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2. 在 Maven 的构建插件中, 添加热部署插件12345678910&lt;!-- 热部署 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 如果没有该项配置devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt;&lt;!--支持静态文件热部署--&gt; &lt;/configuration&gt;&lt;/plugin&gt; 3. 设置IDEA3.1. Command + , –&gt; 查找 Compiler 3.2. Command + Shift + A –&gt; 查找make project automatically 3.3. Command + Shift + A –&gt; 查找 Registry –&gt; 找到并勾选compiler.automake.allow.when.app.running]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Redis]]></title>
    <url>%2F2018%2F03%2F15%2Farticle%2FSpringBoot%2Farticle-spring-boot_05%2F</url>
    <content type="text"><![CDATA[SpringBoot 对 Redis的基本操作 Redis一共支持5种数据类型，每种数据类型对应不同的数据结构，有简单的string、list、hash、set(字典)、zet(跳跃表)。跳跃表是比较新型的数据结构，常用于高性能的查找，可以达到log2N的查询速度，而且跳跃表相对于红黑树，在更新时变更的节点较少，更易于实现并发操作。 Redis提供了两种持久机制，包括RDB和AOF，前者是定时的持久机制，但在出现宕机时可能会出现数据丢失，后者是基于操作日志的持久机制。 1. 添加pom.xml依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2. 添加配置信息1234567891011spring: redis: database: 0 # Redis数据库索引（默认为0） host: 127.0.0.1 # Redis服务器地址 port: 6379 # Redis服务器连接端口 password: # Redis服务器连接密码（默认为空） pool.max-active: 8 # 连接池最大连接数（使用负值表示没有限制） pool.max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） pool.max-idle: 8 # 连接池中的最大空闲连接 pool.min-idle: 0 # 连接池中的最小空闲连接 timeout: 0 # 连接超时时间（毫秒） 3. 新增RedisConfig类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package pro.yuchen.demo.spring_demo.redis;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import java.lang.reflect.Method;@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, Method method, Object... params) &#123; StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125; @SuppressWarnings("rawtypes") @Bean public CacheManager cacheManager(RedisTemplate redisTemplate) &#123; RedisCacheManager rcm = new RedisCacheManager(redisTemplate); //设置缓存过期时间// rcm.setDefaultExpiration(60);//秒 return rcm; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; 4. 测试RedisTemplate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package pro.yuchen.demo.spring_demo.redis;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.test.context.junit4.SpringRunner;import pro.yuchen.demo.spring_demo.entity.Book;import pro.yuchen.demo.spring_demo.entity.User;import java.util.Date;import java.util.concurrent.TimeUnit;@RunWith(SpringRunner.class)@SpringBootTestpublic class RedisTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate redisTemplate; @Test public void test() throws Exception &#123; stringRedisTemplate.opsForValue().set("aaa", "张三"); Assert.assertEquals("张三", stringRedisTemplate.opsForValue().get("aaa")); &#125; @Test public void testObj() throws Exception &#123; User user=new User(); user.setName("tom"); user.setAge(10); user.setId(1L); User user1 = new User(); user1.setName("Jack"); user1.setAge(48); user1.setId(3L); Book book = new Book(); book.setDate(new Date()); book.setId(1); book.setName("hheehe"); book.setPress("aaa").setPress("bbb").setPress("ccc"); Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss.SSS").create(); String book_json = gson.toJson(book); ValueOperations&lt;String, Object&gt; operations = redisTemplate.opsForValue(); operations.set("com.neox", user); operations.set("com.neo.f", user1); operations.set("book", book_json); Book book1 = gson.fromJson(operations.get("book").toString(), Book.class); operations.set("com.neo.f", user,99, TimeUnit.SECONDS); Thread.sleep(1000); redisTemplate.delete("com.neo.f"); boolean exists=redisTemplate.hasKey("com.neo.f"); if(exists)&#123; System.out.println("exists is true"); &#125;else&#123; System.out.println("exists is false"); &#125; // Assert.assertEquals("aa", operations.get("com.neo.f").getUserName()); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 统一处理错误]]></title>
    <url>%2F2018%2F03%2F13%2Farticle%2FSpringBoot%2Farticle-spring-boot_04%2F</url>
    <content type="text"><![CDATA[SpringBoot 统一处理错误信息 1. 定义公共异常类123456789101112131415161718192021222324252627282930313233343536373839404142434445package pro.yuchen.demo.spring_demo.pojo;/** * HTTP请求通用错误信息 */public class GlobalException extends Exception &#123; /** * 错误的状态码 */ private Integer code; /** * HTTP 错误信息 */ private String message; /** * HTTP 返回数据(JSON 格式) */ private String data; public GlobalException(Integer code, String message) &#123; super(message); this.code = code; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 2. 定义页面异常类12345678910111213141516171819202122232425262728293031323334353637383940414243package pro.yuchen.demo.spring_demo.pojo;/** * 页面错误信息 */public class PageException extends Exception &#123; /** * 错误的状态码 */ private Integer code; /** * 错误信息 */ private String message; /** * 返回数据 */ private String data; public PageException(Integer code, String message) &#123; super(message); this.code = code; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 3. 定义异常拦截类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pro.yuchen.demo.spring_demo.web;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import pro.yuchen.demo.spring_demo.entity.Book;import pro.yuchen.demo.spring_demo.pojo.GlobalException;import pro.yuchen.demo.spring_demo.pojo.PageException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.*;@ControllerAdvicepublic class GlobalExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); @ExceptionHandler(value = GlobalException.class) @ResponseBody public Map&lt;String, Object&gt; defaultErrorHandler(HttpServletResponse response, HttpServletRequest request, GlobalException e) throws Exception &#123; logger.error("", e); Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put("code", e.getCode()); result.put("message", e.getMessage()); result.put("data", e.getData()); response.setStatus(e.getCode()); return result; // 返回 JSON &#125; @ExceptionHandler(value = &#123;PageException.class&#125;) public ModelAndView pageErrorHandler(PageException e) throws Exception &#123; logger.error("", e); ModelAndView m = new ModelAndView(); // 设置返回数据 m.addObject("code", e.getCode()); m.addObject("message", e.getMessage()); m.addObject("data", e.getData()); // 设置返回页面 m.setViewName("error/500"); return m; // 返回thymeleaf渲染的页面 &#125;&#125; 4. 新建Error页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title th:text="$&#123;code&#125;"&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;span th:text="$&#123;message&#125;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 4.1. 新建error页面路径 5. 新建Web接口, 测试异常12345678910111213141516171819202122package pro.yuchen.demo.spring_demo.web;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import pro.yuchen.demo.spring_demo.pojo.GlobalException;import pro.yuchen.demo.spring_demo.pojo.PageException;@RestControllerpublic class ErrorController &#123; @RequestMapping("/error/&#123;id&#125;") public String error(@PathVariable Integer id) throws Exception &#123; if(id &lt; 20) &#123; throw new GlobalException(503, "测试......."); &#125; else if (id &gt; 50) &#123; throw new PageException(500, "测试页面"); &#125; return "error"; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Thymeleaf]]></title>
    <url>%2F2018%2F03%2F10%2Farticle%2FSpringBoot%2Farticle-spring-boot_03%2F</url>
    <content type="text"><![CDATA[SpringBoot 使用 Thymeleaf 模板渲染页面 1. 引入pom文件1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2. 修改配置文件(application.yml)1234567891011121314spring: # 模板配置 thymeleaf: # 这个开发配置为false，避免改了模板还要重启服务器 cache: false check-template-location: true content-type: text/html enabled: true encoding: utf-8 mode: HTML5 prefix: classpath:/templates/ suffix: .html excluded-view-names: template-resolver-order: 3. 新建静态页面(Thymeleaf渲染)12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;Thymeleaf Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;变量表达式&lt;/h2&gt; &lt;span th:text="$&#123;book.name&#125;"&gt;&lt;/span&gt; &lt;h2&gt;选择(星号)表达式&lt;/h2&gt; &lt;div th:object="$&#123;book&#125;"&gt; ID: &lt;span th:text="*&#123;id&#125;"&gt;&lt;/span&gt;&lt;br/&gt; NAME: &lt;span th:text="*&#123;name&#125;"&gt;&lt;/span&gt;&lt;br/&gt; Date: &lt;span th:text="*&#123;#dates.format(date, 'yyyy-MM-dd HH:mm:ss.SSS')&#125;"&gt;&lt;/span&gt;&lt;br/&gt; Press:&lt;br/&gt; &lt;span th:each="p : *&#123;press&#125;"&gt; &lt;span th:text="$&#123;p&#125;"&gt;&lt;/span&gt;&lt;br/&gt; &lt;/span&gt; &lt;/div&gt; &lt;h2&gt;URL表达式&lt;/h2&gt; &lt;a href="main.html" th:href="@&#123;./404&#125;"&gt;URL-TEST&lt;/a&gt; &lt;a th:href="@&#123;/hello&#125;"&gt;hello&lt;/a&gt; &lt;h2&gt;常见的几种用法&lt;/h2&gt; &lt;h4&gt;1. 拼接字符串&lt;/h4&gt; &lt;span th:text="|Welcome to our application, $&#123;book.name&#125;!|"&gt;&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 4. 新建Web响应接口1234567891011121314151617181920212223package pro.yuchen.demo.spring_demo.thymeleaf;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controller // 如果使用@RestController，页面只返回index这个字符串，这个注解等同于使用@ResponseBodypublic class ThymeleafController &#123; @RequestMapping(value = &#123;"/", "", "/index.html"&#125;) public String index(ModelMap m) &#123; // 加入一个属性，用来在模板中读取 Book book = new Book(); book.setId(1); book.setName("Java 编程思想"); book.setPress("Bruce").setPress("李述昱"); book.setDate(new Date()); m.put("book", book); m.put("url", "404.html"); // return模板文件的名称，对应src/main/resources/templates/index.html return "index"; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 初体验]]></title>
    <url>%2F2018%2F03%2F06%2Fnode%2Fdatabase%2Fnode-redis_1%2F</url>
    <content type="text"><![CDATA[MacOS 中安装并使用Redis 安装 用docker 拉取redis镜像文件 1docker pull redis 启动redis容器 1docker run --name redis -p 6379:6379 -d redis 启用持久化 1docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 更详细的说明 1https://dev.aliyun.com/detail.html?spm=5176.1971733.2.19.OSaOMd&amp;repoId=1259 Redis 常用命令 启动|停止 Redis 服务 1redis-server start | stop 启动 Redis 客户端 1redis-cli 关闭 Redis 客户端 1redis-cli shutdown 写入数据 1set foo bar 读取数据 1get foo 查看所有keys 1keys * 查看前缀为”prefix_”的所有keys 1keys prefix_* 清除当前数据库的所有keys 1flushdb 清除所有数据库的所有keys 1flushall Java 操作 Redis​ 使用Maven管理jar包 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;pro.yuchen.demo&lt;/groupId&gt; &lt;artifactId&gt;RedisDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ​ 这是一个简单的测试例子. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package pro.yuchen.dome.dao;import java.util.ArrayList;import java.util.List;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.JedisShardInfo;import redis.clients.jedis.ShardedJedis;import redis.clients.jedis.ShardedJedisPool;/** * redis的Java客户端Jedis测试验证 * * @author */public class Test &#123; /** * 非切片客户端链接 */ private Jedis jedis; /** * 非切片链接池 */ private JedisPool jedisPool; /** * 切片客户端链接 */ private ShardedJedis shardedJedis; /** * 切片链接池 */ private ShardedJedisPool shardedJedisPool; private String ip = "127.0.0.1"; /** * 构造函数 */ public Test() &#123; initialPool(); initialShardedPool(); shardedJedis = shardedJedisPool.getResource(); jedis = jedisPool.getResource(); &#125; private void initialPool() &#123; // 池基本配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxActive(20); config.setMaxIdle(5); config.setMaxWait(-1); config.setTestOnBorrow(false); jedisPool = new JedisPool(config, ip, 6379); &#125; /** * 初始化切片池 */ private void initialShardedPool() &#123; // 池基本配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxActive(20); config.setMaxIdle(5); config.setMaxWait(-1); config.setTestOnBorrow(false); // slave链接 List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(); shards.add(new JedisShardInfo(ip, 6379, "master")); // 构造池 shardedJedisPool = new ShardedJedisPool(config, shards); &#125; public void show() &#123; // key检测 testKey(); // string检测 testString(); // list检测 testList(); // set检测 testSet(); // sortedSet检测 testSortedSet(); // hash检测 testHash(); shardedJedisPool.returnResource(shardedJedis); &#125; private void testKey() &#123; System.out.println("=============key=========================="); // 清空数据 System.out.println(jedis.flushDB()); System.out.println(jedis.echo("foo")); // 判断key否存在 System.out.println(shardedJedis.exists("foo")); shardedJedis.set("key", "values"); System.out.println(shardedJedis.exists("key")); &#125; private void testString() &#123; System.out.println("=============String=========================="); // 清空数据 System.out.println(jedis.flushDB()); // 存储数据 shardedJedis.set("foo", "bar"); System.out.println(shardedJedis.get("foo")); // 若key不存在，则存储 shardedJedis.setnx("foo", "foo not exits"); System.out.println(shardedJedis.get("foo")); // 覆盖数据 shardedJedis.set("foo", "foo update"); System.out.println(shardedJedis.get("foo")); // 追加数据 shardedJedis.append("foo", " hello, world"); System.out.println(shardedJedis.get("foo")); // 设置key的有效期，并存储数据 shardedJedis.setex("foo", 2, "foo not exits"); System.out.println(shardedJedis.get("foo")); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(shardedJedis.get("foo")); // 获取并更改数据 shardedJedis.set("foo", "foo update"); // 返回修改前的数据 System.out.println(shardedJedis.getSet("foo", "foo modify")); System.out.println(shardedJedis.get("foo")); // 截取value的值 System.out.println(shardedJedis.getrange("foo", 1, 3)); // 存储多组key-value System.out.println(jedis.mset("mset1", "mvalue1", "mset2", "mvalue2", "mset3", "mvalue3", "mset4", "mvalue4")); // 获取多个key的value, 返回数组 System.out.println(jedis.mget("mset1", "mset2", "mset3", "mset4")); // 删除多个key, 不存在的key, 不会报错, 返回删除数 System.out.println(jedis.del(new String[] &#123; "foo", "foo1", "foo3" &#125;)); &#125; private void testList() &#123; System.out.println("=============list=========================="); // 清空数据 System.out.println(jedis.flushDB()); // 添加数据 shardedJedis.lpush("lists", "23"); shardedJedis.lpush("lists", "77"); shardedJedis.lpush("lists", "58"); // 数组长度 System.out.println(shardedJedis.llen("lists")); // 排序 System.out.println(shardedJedis.sort("lists")); // List的字符串数组 System.out.println(shardedJedis.lrange("lists", 0, 3)); // 修改列表中单个值 shardedJedis.lset("lists", 0, "9"); // 获取列表指定下标的值 System.out.println(shardedJedis.lindex("lists", 1)); // 出栈列表指定数量的指定值, 返回实际出栈数量 System.out.println(shardedJedis.lrem("lists", 1, "58")); // 删除区间以外的数据 System.out.println(shardedJedis.ltrim("lists", 0, 2)); // 列表出栈(返回并删除列表中第一个元素) System.out.println(shardedJedis.lpop("lists")); // 整个列表值 System.out.println(shardedJedis.lrange("lists", 0, -1)); &#125; private void testSet() &#123; System.out.println("=============set=========================="); // 清空数据 System.out.println(jedis.flushDB()); // 添加数据 shardedJedis.sadd("sets", "HashSet"); shardedJedis.sadd("sets", "SortedSet"); shardedJedis.sadd("sets", "TreeSet"); // 判断value是否在列表中 System.out.println(shardedJedis.sismember("sets", "TreeSet")); // 整个列表值 System.out.println(shardedJedis.smembers("sets")); // 删除指定元素 System.out.println(shardedJedis.srem("sets", "SortedSet")); // 出栈 System.out.println(shardedJedis.spop("sets")); System.out.println(shardedJedis.smembers("sets")); shardedJedis.sadd("sets1", "HashSet1"); shardedJedis.sadd("sets1", "SortedSet1"); shardedJedis.sadd("sets1", "TreeSet"); shardedJedis.sadd("sets2", "HashSet2"); shardedJedis.sadd("sets2", "SortedSet1"); shardedJedis.sadd("sets2", "TreeSet1"); // 交集 System.out.println(jedis.sinter("sets1", "sets2")); // [SortedSet1] // 并集 System.out.println(jedis.sunion("sets1", "sets2")); // [HashSet2, HashSet1, TreeSet1, TreeSet, SortedSet1] // 差集 System.out.println(jedis.sdiff("sets1", "sets2")); // [TreeSet, HashSet1] &#125; private void testSortedSet() &#123; System.out.println("=============zset=========================="); // 清空数据 System.out.println(jedis.flushDB()); // 添加数据 shardedJedis.zadd("zset", 10.1, "hello"); shardedJedis.zadd("zset", 10.0, ":"); shardedJedis.zadd("zset", 9.0, "zset"); shardedJedis.zadd("zset", 11.0, "zset!"); // 元素个数 System.out.println(shardedJedis.zcard("zset")); // 元素下标 System.out.println(shardedJedis.zscore("zset", "zset")); // 集合子集 System.out.println(shardedJedis.zrange("zset", 0, -1)); // 删除元素 System.out.println(shardedJedis.zrem("zset", "zset!")); System.out.println(shardedJedis.zcount("zset", 9.5, 10.5)); // 整个集合值 System.out.println(shardedJedis.zrange("zset", 0, -1)); &#125; private void testHash() &#123; System.out.println("=============hash=========================="); // 清空数据 System.out.println(jedis.flushDB()); // 添加数据 shardedJedis.hset("hashs", "entryKey", "entryValue"); shardedJedis.hset("hashs", "entryKey1", "entryValue1"); shardedJedis.hset("hashs", "entryKey2", "entryValue2"); // 判断某个值是否存在 System.out.println(shardedJedis.hexists("hashs", "entryKey")); // 获取指定的值 System.out.println(shardedJedis.hget("hashs", "entryKey")); // 批量获取指定的值 System.out.println(shardedJedis.hmget("hashs", "entryKey", "entryKey1")); // 删除指定的值 System.out.println(shardedJedis.hdel("hashs", "entryKey")); // 为key中的域 field 的值加上增量 increment System.out.println(shardedJedis.hincrBy("hashs", "entryKey", 123l)); // 获取所有的keys System.out.println(shardedJedis.hkeys("hashs")); // 获取所有的values System.out.println(shardedJedis.hvals("hashs")); &#125; public static void main(String[] args) &#123; new Test().show(); &#125;&#125; 注: 所谓 切片 就是在分布式应用中使用的. Python 操作 Redis12]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 配置自定义属性与多环境开发]]></title>
    <url>%2F2018%2F03%2F05%2Farticle%2FSpringBoot%2Farticle-spring-boot_02%2F</url>
    <content type="text"><![CDATA[SpringBoot 中配置自定义属性, 与多环境开发. 自定义的配置属性这里我用的是 application.yml 文件. 123456config: user: name: Mr.Li age: 27 sex: 男 application: 單車 实体Bean通过 @ConfigurationProperties 配置注入的内容. 12345678910111213141516171819202122232425262728293031323334353637383940package pro.yuchen.demo.spring_demo.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * 提供系统的一些配置信息 */@Component@ConfigurationProperties(prefix="config.user")public class ConfigBean &#123; private String name; private Integer age; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 测试自动注入ConfigBean 123456789101112131415161718192021222324252627282930313233343536373839404142package pro.yuchen.demo.spring_demo;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import pro.yuchen.demo.spring_demo.pojo.ConfigBean;import pro.yuchen.demo.spring_demo.web.HelloController;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class, Application.class&#125;)@WebAppConfigurationpublic class ApplicationTests &#123; @Autowired private ConfigBean config; @Value("$&#123;config.application&#125;") // 获取配置文件中的单独key private String application; @Test public void testConfigBean() &#123; System.out.println(config.getName()); System.out.println(config.getAge()); System.out.println(config.getSex()); System.out.println(application); &#125; &#125; 多环境开发很多时候, 在实际开发过程中, 我们的开发环境和线上的部署环境, 是有差异的. 让配置文件中属性的值, 随着编译环境的改变而改变, 就可以了. 在pom.xml文件中添加: 1234567891011121314151617181920&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;config.key&gt;call&lt;/config.key&gt; &lt;config.value&gt;123456&lt;/config.value&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;localhost&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- 默认有效 --&gt; &lt;/activation&gt; &lt;properties&gt; &lt;config.key&gt;password&lt;/config.key&gt; &lt;config.value&gt;18733775865&lt;/config.value&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 修改 application.yml 文件: 12345678config: user: name: Mr.Li age: 27 sex: 男 key: @config.key@ value: @config.value@ application: 單車 修改 ConfigBean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package pro.yuchen.demo.spring_demo.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * 提供系统的一些配置信息 */@Component@ConfigurationProperties(prefix="config.user")public class ConfigBean &#123; private String name; private Integer age; private String sex; private String key; private String value; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125;&#125; 修改测试用例: 1234567891011121314151617181920212223242526272829303132333435363738394041import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import pro.yuchen.demo.spring_demo.pojo.ConfigBean;import pro.yuchen.demo.spring_demo.web.HelloController;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class, Application.class&#125;)@WebAppConfigurationpublic class ApplicationTests &#123; @Autowired private ConfigBean config; @Value("$&#123;config.application&#125;") // 获取配置文件中的单独key private String application; @Test public void testConfigBean() &#123; System.out.println(config.getName()); System.out.println(config.getAge()); System.out.println(config.getSex()); System.out.println(config.getKey()); // 默认输出 password System.out.println(config.getValue()); // 默认输出 18733775865 System.out.println(application); &#125; &#125; 使用 dev 分支进行编译 mvn clean install -P dev]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot HelloWorld以及单元测试]]></title>
    <url>%2F2018%2F02%2F25%2Farticle%2FSpringBoot%2Farticle-spring-boot_01%2F</url>
    <content type="text"><![CDATA[SpringBoot 的HelloWorld以及单元测试 pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;pro.yuchen.deom&lt;/groupId&gt; &lt;artifactId&gt;spring-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;!-- 引用父项目pom--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;!-- 自定义属性 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Maven 构建插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 启动类12345678910111213package pro.yuchen.demo.spring_demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; application.yml(配置文件)123# webserver: port: 8081 Controller(Web接口)1234567891011121314151617package pro.yuchen.demo.spring_demo.web;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import pro.yuchen.demo.spring_demo.pojo.ConfigBean;@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello() &#123; return "Hello World"; &#125;&#125; Web访问接口http://localhost:8081/hello TestController(测试Web接口)123456789101112131415161718192021222324252627282930313233343536import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.http.MediaType;import org.springframework.mock.web.MockServletContext;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import pro.yuchen.demo.spring_demo.web.HelloController;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = &#123;MockServletContext.class&#125;)@WebAppConfigurationpublic class ApplicationTests &#123; private MockMvc mvc; @Before public void setup() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; @Test public void testHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo("Hello World"))); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 中常用的状态码]]></title>
    <url>%2F2018%2F02%2F24%2Fnode%2Fnode-httpcode_1%2F</url>
    <content type="text"><![CDATA[HTTP 中常用的状态码 HTTP 中常用的状态码常见的状态码: HTTP: Status 200 – 服务器成功返回网页HTTP: Status 404 – 请求的网页不存在HTTP: Status 503 – 服务不可用 ### HTTP: Status 1xx (临时响应) 表示临时响应并需要请求者继续执行操作的状态代码。 详细代码及说明 : HTTP: Status 100 (继续) -&gt; 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 HTTP: Status 101 (切换协议) -&gt; 请求者已要求服务器切换协议，服务器已确认并准备切换。 HTTP Status 2xx (成功) 表示成功处理了请求的状态代码。 详细代码及说明 : HTTP Status 200 (成功) -&gt; 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 HTTP Status 201 (已创建) -&gt; 请求成功并且服务器创建了新的资源。 HTTP Status 202 (已接受) -&gt; 服务器已接受请求，但尚未处理。 HTTP Status 203 (非授权信息) -&gt; 服务器已成功处理了请求，但返回的信息可能来自另一来源。 HTTP Status 204 (无内容) -&gt; 服务器成功处理了请求，但没有返回任何内容。 HTTP Status 205 (重置内容) -&gt; 服务器成功处理了请求，但没有返回任何内容。 HTTP Status 206 (部分内容) -&gt; 服务器成功处理了部分 GET 请求。 HTTP Status 4xx (请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。 详细代码说明 : HTTP Status 400 （错误请求） -&gt; 服务器不理解请求的语法。 HTTP Status 401 （未授权） -&gt; 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 HTTP Status 403 （禁止） -&gt; 服务器拒绝请求。 HTTP Status 404 （未找到） -&gt; 服务器找不到请求的网页。 HTTP Status 405 （方法禁用） -&gt; 禁用请求中指定的方法。 HTTP Status 406 （不接受） -&gt; 无法使用请求的内容特性响应请求的网页。 HTTP Status 407 （需要代理授权） -&gt; 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 HTTP Status 408 （请求超时） -&gt; 服务器等候请求时发生超时。 HTTP Status 409 （冲突） -&gt; 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 HTTP Status 410 （已删除） -&gt; 如果请求的资源已永久删除，服务器就会返回此响应。 HTTP Status 411 （需要有效长度） -&gt; 服务器不接受不含有效内容长度标头字段的请求。 HTTP Status 412 （未满足前提条件） -&gt; 服务器未满足请求者在请求中设置的其中一个前提条件。 HTTP Status 413 （请求实体过大） -&gt; 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 HTTP Status 414 （请求的 URI 过长） -&gt; 请求的 URI（通常为网址）过长，服务器无法处理。 HTTP Status 415 （不支持的媒体类型） -&gt; 请求的格式不受请求页面的支持。 HTTP Status 416 （请求范围不符合要求） -&gt; 如果页面无法提供请求的范围，则服务器会返回此状态代码。 HTTP Status 417 （未满足期望值） -&gt; 服务器未满足”期望”请求标头字段的要求。 HTTP Status 5xx （服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码详细及说明 : HTTP Status 500 （服务器内部错误） -&gt; 服务器遇到错误，无法完成请求。 HTTP Status 501 （尚未实施） -&gt; 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 ####HTTP Status 502 （错误网关） -&gt; 服务器作为网关或代理，从上游服务器收到无效响应。 HTTP Status 503 （服务不可用） -&gt; 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 HTTP Status 504 （网关超时） -&gt; 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 HTTP Status 505 （HTTP 版本不受支持） -&gt; 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 初体验]]></title>
    <url>%2F2018%2F02%2F23%2Fnode%2Fnode-maven_1%2F</url>
    <content type="text"><![CDATA[Maven 中常用的命令以及一些基础配置 Maven项目打包 mvn package 项目编译 mvn compile 编译测试程序 mvn test-compile 运行测试 mvn test 清理项目 mvn clean 生成站点目录 mvn site 生成站点目录并发布 mvn site-deploy 安装当前工程的输出文件到本地仓库 mvn install 根据pom中的配置信息将项目发布到远程仓库中 mvn clean deploy 跳过测试输出到本地仓库 mvn -Dmaven.test.skip=true clean install 打包本地工程并上传到远程仓库 mvn clean deploy 清理编译 mvn clean compile 清理测试 mvn clean test 清理打包 mvn clean package 使用Archetype生成项目骨架 mvn archetype:generate 选择配置参数, 构建Maven项目 1234567891011121314151617181920&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;config.key&gt;call&lt;/config.key&gt; &lt;config.value&gt;123456&lt;/config.value&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;localhost&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;config.key&gt;password&lt;/config.key&gt; &lt;config.value&gt;654321&lt;/config.value&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; mvn clean install -P dev 在 settings.xml 文件中, 配置远程仓库的访问权限 12345678910111213&lt;servers&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 我们需要配置POM的distributionManagement来指定Maven远程仓库的地址 1234567891011121314&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://mvnlib.jk24h.cn:8081/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://mvnlib.jk24h.cn:8081/nexus/content/repositories/snapshots&lt;/url&gt; &lt;uniqueVersion&gt;false&lt;/uniqueVersion&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Mavenkk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 初体验]]></title>
    <url>%2F2018%2F02%2F22%2Fnode%2Fnode-git_01%2F</url>
    <content type="text"><![CDATA[Git 中常用的命令以及一些基础配置 Git 常用的命令 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 在当前目录新建一个Git代码库 $ git init 新建一个目录，将其初始化为Git代码库 $ git init [project-name] 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 $ git config –list 编辑Git配置文件 $ git config -e [–global] 设置提交代码时的用户信息 $ git config [–global] user.name “[name]” $ git config [–global] user.email “[email address]” 三、增加/删除文件 添加指定文件到暂存区 $ git add [file1] [file2] … 添加指定目录到暂存区，包括子目录 $ git add [dir] 添加当前目录的所有文件到暂存区 $ git add . 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 $ git add -p 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] … 停止追踪指定文件，但该文件会保留在工作区 $ git rm –cached [file] 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 提交暂存区到仓库区 $ git commit -m [message] 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 提交时显示所有diff信息 $ git commit -v 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化 $ git commit –amend [file1] [file2] … 五、分支 列出所有本地分支 $ git branch 列出所有远程分支 $ git branch -r 列出所有本地分支和远程分支 $ git branch -a 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 新建一个分支，并切换到该分支 $ git checkout -b [branch] 新建一个分支，指向指定commit $ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 $ git branch –track [branch] [remote-branch] 切换到指定分支，并更新工作区 $ git checkout [branch-name] 切换到上一个分支 $ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支 $ git merge [branch] 选择一个commit，合并进当前分支 $ git cherry-pick [commit] 删除分支 $ git branch -d [branch-name] 删除远程分支 $ git push origin –delete [branch-name] $ git branch -dr [remote/branch] 六、标签 列出所有tag $ git tag 新建一个tag在当前commit $ git tag [tag] 新建一个tag在指定commit $ git tag [tag] [commit] 删除本地tag $ git tag -d [tag] 删除远程tag $ git push origin :refs/tags/[tagName] 查看tag信息 $ git show [tag] 提交指定tag $ git push [remote] [tag] 提交所有tag $ git push [remote] –tags 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log 显示commit历史，以及每次commit发生变更的文件 $ git log –stat 搜索提交历史，根据关键词 $ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD –grep feature 显示某个文件的版本历史，包括文件改名 $ git log –follow [file] $ git whatchanged [file] 显示指定文件相关的每一次diff $ git log -p [file] 显示过去5次提交 $ git log -5 –pretty –oneline 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 显示指定文件是什么人在什么时间修改过 $ git blame [file] 显示暂存区和工作区的差异 $ git diff 显示暂存区和上一个commit的差异 $ git diff –cached [file] 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 显示两次提交之间的差异 $ git diff [first-branch]…[second-branch] 显示今天你写了多少行代码 $ git diff –shortstat “@{0 day ago}” 显示某次提交的元数据和内容变化 $ git show [commit] 显示某次提交发生变化的文件 $ git show –name-only [commit] 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 显示当前分支的最近几次提交 $ git reflog 八、远程同步 下载远程仓库的所有变动 $ git fetch [remote] 显示所有远程仓库 $ git remote -v 显示某个远程仓库的信息 $ git remote show [remote] 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] –force 推送所有分支到远程仓库 $ git push [remote] –all 九、撤销 恢复暂存区的指定文件到工作区 $ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 恢复暂存区的所有文件到工作区 $ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 重置暂存区与工作区，与上一次commit保持一致 $ git reset –hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset –hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset –keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他 生成一个可供发布的压缩包 $ git archive 配置全局的过滤文件 $ git config --global core.excludesfile ~/development/workspace/.gitignore 123456*.classtarget/*.iml.settings/bin/.idea/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 笔记]]></title>
    <url>%2F2018%2F02%2F13%2Fnode%2Flinux%2Fnode-docker_01%2F</url>
    <content type="text"><![CDATA[Docker 日常使用命令 Docker 常用命令下载镜像 docker pull centos 查看镜像 docker images 删除镜像 docker rmi 备份镜像 docker commit -p 36b7b593a0e2 hbase-backup 36b7b593a0e2 为容器id, hbase-backup 为 备份名 备份镜像到文件 docker save -o ~/hbase-backup.tar hbase-backup 恢复镜像文件 docker load -i ~/Downloads/hbase-backup.tar 创建并启动交互型容器 docker run -ti –name=docker_centos centos:latest /bin/bash t: 告诉docker为容器建立一个命令行终端 i: 打开容器的标准输入 name: 指定容器名称，可以不填(随机)，建议根据具体使用功能命名，便于管理 /bin/bash:告诉docker要在容器里面执行此命令 创建并启动后台型容器 docker run –name linux -d centos /bin/bash -c “while true; do echo hello; sleep 1; done” d:使用-d参数，使容器在后台运行 c: 通过-c可以调整容器的CPU优先级 -c后的命令是循环，从而保持容器的运行 进入容器 docker exec -ti CentOS /bin/bash 退出容器 先按，ctrl+p; 再按，ctrl+q 平时进入HBase的命令 $ docker start hbase $ docker exec -ti hbase /bin/bash]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBase 常用命令]]></title>
    <url>%2F2018%2F02%2F13%2Fnode%2Fdatabase%2Fnode-hbase_2%2F</url>
    <content type="text"><![CDATA[HBase 日常使用命令 查看所在组 whoami 查看所在组中的表list 判断表是否存在exists &#39;lishuyu&#39; 将表设为失效状态disable &#39;lishuyu&#39; 判断表的状态is_enabled &#39;lishuyu&#39; 将表设为正常状态 enable &#39;lishuyu&#39; 删除表drop &#39;lishuyu&#39; 创建表(lishuyu –&gt; 表名, cluster1,cluster2 –&gt; 簇名, 没有具体的列名)create &#39;lishuyu&#39;,{NAME =&gt; &#39;cluster1&#39;, VERSIONS =&gt; 2},{NAME =&gt; &#39;cluster2&#39;, VERSIONS =&gt; 2} 查看表结构 describe &#39;lishuyu&#39; 插入数据(一次只可以插入一个单元格的值)put &#39;lishuyu&#39;,&#39;rowkey001&#39;,&#39;cluster1:col1&#39;,&#39;col1-value-001&#39; 查询数据(lishuyu –&gt; 表名, cluster2 –&gt; 簇名, col2 –&gt; 列名), 查询 rowkey001 行, cluster2 簇, col2 列 的数据get &#39;lishuyu&#39;,&#39;rowkey001&#39;, &#39;cluster2:col2&#39; 查询 rowkey001 行 的数据get &#39;lishuyu&#39;,&#39;rowkey001&#39; 扫描表scan &#39;lishuyu&#39;,{LIMIT=&gt;1}scan &#39;lishuyu&#39;, {COLUMNS=&#39;cluster2:col1&#39;, LIMIT = 1} 计算lishuyu表合计count &#39;lishuyu&#39; 显示RowKeycount &#39;lishuyu&#39;, {INTERVAL =&gt; 1, CACHE =&gt; 5} 删除表中单元格中的内容delete &#39;lishuyu&#39;,&#39;rowkey001&#39;,&#39;cluster2:col1&#39;]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBase 笔记]]></title>
    <url>%2F2018%2F02%2F12%2Fnode%2Fdatabase%2Fnode-hbase_1%2F</url>
    <content type="text"><![CDATA[HBase 日常使用命令 HBase 初体验安装 HBasedocker pull harisekhon/hbase 创建HBase容器docker run -d --name=hbase -p 2181:2181 -p 8080:8080 -p 8085:8085 -p 9090:9090 -p 9095:9095 -p 16000:16000 -p 16010:16010 -p 16201:16201 -p 16301:16301 harisekhon/hbase 启动 HBase 服务docker start hbase 停止 HBase 服务docker stop hbase 启动 HBase 命令行docker exec -ti hbase /bin/bash 进入 shell hbase shell 退出 shell exit 建表 create ‘SCORE’, {NAME =&gt; ‘F’, VERSIONS =&gt; 1}, {NAME =&gt; ‘M’, VERSIONS =&gt; 1} 删除表 disable ‘SCORE’drop ‘SCORE’ 新增记录 put &#39;&lt;table&gt;&#39;, &#39;&lt;row_key&gt;&#39;, &#39;&lt;column_family:column_qualifier&gt;&#39;, &#39;&lt;cell_value&gt;&#39;, [&lt;timestamp&gt;] 例子 put ‘SCORE’, ‘row_key_1’, ‘M:1’, ‘1’ 删除单元格 delete &#39;&lt;table&gt;&#39;, &#39;&lt;row_key&gt;&#39;, &#39;&lt;column_family:column_qualifier&gt;&#39; [, &lt;timestamp&gt;] 例子 delete ‘SCORE’, ‘row_key_1’, ‘M:1’ 删除行 deleteall &#39;&lt;table&gt;&#39;, &#39;&lt;row_key&gt;&#39; [, &#39;&lt;column_family:column_qualifier&gt;&#39;, &lt;timestamp&gt;] 例子 deleteall ‘SCORE’, ‘row_key_1’ 清空表中数据 truncate &lt;table&gt; 例子 truncate ‘SCORE’ 扫描表 scan &lt;table&gt;, {COLUMNS =&gt; [ &lt;family:column&gt;,.... ], LIMIT =&gt; num} 例子 scan ‘SCORE’, {LIMIT=&gt;2} 查询某行记录 get &lt;table&gt;,&lt;rowkey&gt;,[&lt;family:column&gt;,....] 注: table 表 row_key 行 column_family 列簇 column_qualifier 列]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 操作XML]]></title>
    <url>%2F2018%2F01%2F25%2Farticle%2Fpython%2Farticle-python_12%2F</url>
    <content type="text"><![CDATA[Python 中的XML操作 Python XML操作XML（可扩展性标记语言）是一种非常常用的文件类型，主要用于存储和传输数据。在编程中，对XML的操作也非常常见。 XML格式首先，来看一下XML所包含的元素类型 标签 &lt;tag&gt; 属性 &lt;tag name=&quot;attribute&quot;&gt; 数据 &lt;data&gt;1&lt;data&gt; 例子1234567891011121314151617181920212223&lt;?xml version="1.0"?&gt;&lt;data&gt; &lt;country name="Liechtenstein"&gt; &lt;rank&gt;1&lt;/rank&gt; &lt;year&gt;2008&lt;/year&gt; &lt;gdppc&gt;141100&lt;/gdppc&gt; &lt;neighbor name="Austria" direction="E"/&gt; &lt;neighbor name="Switzerland" direction="W"/&gt; &lt;/country&gt; &lt;country name="Singapore"&gt; &lt;rank&gt;4&lt;/rank&gt; &lt;year&gt;2011&lt;/year&gt; &lt;gdppc&gt;59900&lt;/gdppc&gt; &lt;neighbor name="Malaysia" direction="N"/&gt; &lt;/country&gt; &lt;country name="Panama"&gt; &lt;rank&gt;68&lt;/rank&gt; &lt;year&gt;2011&lt;/year&gt; &lt;gdppc&gt;13600&lt;/gdppc&gt; &lt;neighbor name="Costa Rica" direction="W"/&gt; &lt;neighbor name="Colombia" direction="E"/&gt; &lt;/country&gt;&lt;/data&gt; Python操作XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#!/usr/bin/env python3# -*- coding: utf-8 -*-import tracebackfrom xml.etree import ElementTree as etclass XMLUtils(object): def __init__(self, file_path): self.__path = file_path self.tree = None def read(self): ''' 读取并解析xml文件 return: True or False ''' try: tree = et.ElementTree() tree.parse(self.__path) self.tree = tree return True except Exception as e: print("读取XML失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def wite(self, path): """ 写入XML到文件 :param path: 文件的路径 :return: True or False """ try: self.tree.write(path, encoding="utf-8", xml_declaration=True) return True except Exception as e: print("写入XML失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def if_match(self, node, kv_map): """ 判断某个节点是否包含所有传入参数属性 :param node: 节点 :param kv_map: 属性及属性值组成的map :return: True or False """ for key in kv_map: if node.get(key) != kv_map.get(key): return False return True def find_nodes(self, path): """ 查找某个路径匹配的所有节点(注意: 路径中不能有&lt;根节点&gt;) :param path: 路径 :return: 匹配的所有节点 """ try: return self.tree.findall(path) except Exception as e: print("写入XML失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return None def get_node_by_key_value(self, nodes, kv_map): """ 根据属性及属性值定位符合的节点，返回节点 :param nodes: 所要查找的节点集合 :param kv_map: 查找属性条件 :return: 符合条件的节点集合 """ result_nodes = [] for node in nodes: if self.if_match(node, kv_map): result_nodes.append(node) return result_nodes def change_node_properties(self, nodes, kv_map, is_delete=False): """ 修改/增加 /删除 节点的属性及属性值 :param nodes: 需要操作属性的节点集合 :param kv_map: 要新增, 修改或删除的属性map :param is_delete: 是否删除属性 :return: True or False """ try: for node in nodes: for key in kv_map: if is_delete: if key in node.attrib: del node.attrib[key] else: node.set(key, kv_map.get(key)) return True except Exception as e: print("操作节点属性失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def change_node_text(self, nodes, text, is_add=False, is_delete=False): """ 改变/增加/删除一个节点的文本 :param nodes: 节点集合 :param text: 文本 :param is_add: 是否新增 :param is_delete: 是否删除 :return: True or False """ try: for node in nodes: if is_add: node.text += text elif is_delete: node.text = "" else: node.text = text return True except Exception as e: print("操作节点文本失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def create_node(self, tag, property_map, content): """ 新建节点 :param tag: 节点名 :param property_map: 节点属性 :param content: 节点文本 :return: 新节点 """ element = et.Element(tag, property_map) element.text = content return element def add_child_node(self, node, element): """ 给指定节点添加子节点 :param node: 指定操作节点 :param element: :return: True or False """ try: node.append(element) return True except Exception as e: print("添加新节点失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def del_node_by_tag_key_value(self, nodes, tag, kv_map): """ 同过属性及属性值定位一个节点，并删除之 :param nodes: 父节点列表 :param tag: 子节点标签 :param kv_map: 属性及属性值列表 :return: True or False """ try: for parent in nodes: childs = parent.getchildren() for child in childs: if child.tag == tag and self.if_match(child, kv_map): parent.remove(child) return True except Exception as e: print("操作节点失败...") # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def list(self): """ 返回xml文件中所有节点数组 :return: """ result = [] for node in self.tree.iter(): # "Tag": node.tag # "Attributes": node.attrib # "Data":, node.text result.append(node) return resultpath = "/Users/smile/test.xml"xml = XMLUtils(path)result = xml.read() # 读取print(result)## 遍历节点# xml.list()# 查询节点# nodes = xml.find_nodes("country/neighbor")# print(nodes)# nodes = xml.get_node_by_key_value(xml.tree.iter(), &#123;"direction": "W", "name": "Switzerland"&#125;)# nodes = xml.get_node_by_key_value(xml.tree.iter(), &#123;"direction": "W", "name": "Mr.Li"&#125;)# print(nodes)# xml.change_node_properties(nodes, &#123;"directions": "F"&#125;, is_delete=True)# nodes = xml.find_nodes("country/year")# xml.change_node_text(nodes, "年", is_add=True)# nodes = xml.get_node_by_key_value(xml.tree.iter(), &#123;"direction": "W", "name": "Mr.Li"&#125;)# print(nodes)# new_node = xml.create_node("xxx", &#123;"x": "1", "xx": "2"&#125;, "XXXX")# xml.add_child_node(nodes[0], new_node)nodes = xml.find_nodes("country/neighbor")xml.del_node_by_tag_key_value(nodes, "xxx", &#123;"x": "1", "xx": "2"&#125;)result = xml.wite(path) # 写入print(result)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 数据库操作(MySQL, HBase)]]></title>
    <url>%2F2018%2F01%2F24%2Farticle%2Fpython%2Farticle-python_11%2F</url>
    <content type="text"><![CDATA[Python 中的数据库操作 Python 数据库操作Python操作MySQL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#!/usr/bin/env python3# -*- coding: utf-8 -*-import pymysqlimport tracebackfrom functools import reduceclass BaseDao: def __exec(self, sql): flag = False # 使用cursor()方法获取操作游标 cursor = self.db_connect.cursor() try: # 执行sql语句 cursor.execute(sql) # 提交 self.db_connect.commit() flag = True except Exception as e: # 打印错误的堆栈信息 info = traceback.format_exc() print(info) # 如果发生错误则回滚 self.db_connect.rollback() # 关闭数据库连接 self.db_connect.close() return flag def __init__(self, user, passwd, host, db, port=3306): # 打开数据库连接 self.db_connect = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset="utf8") def insert(self, table, **kw): ''' :param table: tablename :param kw: &#123;"insert_field":"insert_value"&#125; :return: True or False ''' # SQL 插入语句 fieds = reduce(lambda x, y: "&#123;0&#125;, &#123;1&#125;".format(x, y), kw.keys()) values = reduce(lambda x, y: "&#123;0&#125;, &#123;1&#125;".format("\"%s\"" % x if type(x) == str else x, "\"%s\"" % y if type(y) == str else y), kw.values()) sql = "INSERT INTO &#123;0&#125; (&#123;1&#125;) VALUES(&#123;2&#125;)".format(table, fieds, values) return self.__exec(sql) def delete(self, table, id): ''' :param table: tablename :param id: Primary Key :return: True or False ''' sql = "DELETE FROM &#123;0&#125; WHERE ID = &#123;1&#125;".format(table, id) return self.__exec(sql) def update(self, table, id, **kw): ''' :param table: tablename :param id: Primary Key :param kw: &#123;"update_fields": "update_value"&#125; :return: ''' # 拼装 SQL fields = "" for k, v in kw.items(): fields += k fields += "=" fields += "\"%s\"" % v if type(v) == str else str(v) fields += "," fields = fields[:-1] sql = "UPDATE &#123;0&#125; SET &#123;1&#125; WHERE id = &#123;2&#125;".format(table, fields, id) return self.__exec(sql) def query(self, table, **kw): """ :param table: table_name :param kw: query_condition :return: [&#123;&#125;, &#123;&#125;] """ # 拼装 SQL condition = "" if kw: condition = "WHERE " for k, v in kw.items(): condition += k condition += "=" condition += "\"%s\"" % v if type(v) == str else str(v) condition += " AND " condition = condition[:-5] sql = "SELECT * FROM &#123;0&#125; &#123;1&#125;".format(table, condition) # 使用cursor()方法获取操作游标 # pymysql.cursors.DictCursor 设置查询结果为 dict类型 cursor = self.db_connect.cursor(pymysql.cursors.DictCursor) try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 rows = cursor.fetchall() return rows except Exception as e: # 打印错误的堆栈信息 info = traceback.format_exc() print(info) # 如果发生错误则回滚 self.db_connect.rollback() # 关闭数据库连接 self.db_connect.close()dao = BaseDao("root", "root", "127.0.0.1", "Test")# result = dao.insert("USER", id="2", name="Jack", age=17, city="Shanghai")# print(result)# result = dao.delete("USER", 2)# print(result)# result = dao.update("USER", 1, name="小红", age=23, city="Shanghai")# print(result)result = dao.query("USER")print(result) Python操作HBase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/env python3# -*- coding: utf-8 -*-import tracebackimport happybase as hbclass HBaseDao: def __convert(self, dict): result = &#123;&#125; for k, v in dict.items(): result[k.decode("utf-8")] = v.decode("utf-8") return result def __init__(self, table, host="localhost", port=9090): """ :param table: table name :param host: h-base host :param port: h-base port """ try: self.__connection = hb.Connection(host, port) self.__connection.open() self.__table = self.__connection.table(table) except Exception as e: print("连接 HBase &#123;0&#125;:&#123;1&#125; 失败...".format(host, port)) # 打印错误的堆栈信息 info = traceback.format_exc() print(info) def insert(self, rowkey, columns): # 将字符编码成2进制 """ :param rowkey: row key :param columns: &#123;"column_family:column_qualifier":"value"&#125; :return: True or False """ try: rowkey = rowkey.encode(encoding='utf-8') columnsByte = &#123;&#125; for k, v in columns.items(): columnsByte[k.encode(encoding='utf-8')] = v.encode(encoding='utf-8') self.__table.put(rowkey, columnsByte) # 插入数据 return True except Exception as e: print("插入 HBase 失败, row_key:&#123;0&#125;, data:&#123;1&#125;".format(rowkey, columns)) # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def insert_all(self, data): """ :param data: &#123;"row_key":&#123;"column_family:column_qualifier":"value"&#125;&#125; :return: True or False """ try: # 使用batch一次插入多行数据 bat = self.__table.batch() for row_key, columns in data.items(): columnsByte = &#123;&#125; for k, v in columns.items(): columnsByte[k.encode(encoding='utf-8')] = v.encode(encoding='utf-8') bat.put(row_key.encode(encoding='utf-8'), columnsByte) bat.send() return True except Exception as e: print("插入 HBase 失败 data:&#123;0&#125;".format(data)) # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def delete_row(self, row_key): try: bat = self.__table.batch() bat.delete(row_key) bat.send() return True except Exception as e: print("删除 HBase 失败 row_key:&#123;0&#125;".format(row_key)) # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def delete_columns(self, row_key, *columns): try: if len(columns) == 0: raise AttributeError("缺失要删除的列") self.__table.delete(row_key, columns) return True except Exception as e: print("删除 HBase 失败 row_key:&#123;0&#125;".format(row_key)) # 打印错误的堆栈信息 info = traceback.format_exc() print(info) return False def query(self, *row_keys): ''' :param row_keys: :return: &#123;"row_key":&#123;"column_family:column_qualifier":"value"&#125;&#125; ''' result = None if len(row_keys) == 1: result = self.__table.row(row_keys[0]) result = self.__convert(result) result = &#123;row_keys[0]:result&#125; elif len(row_keys) &gt; 1: result = &#123;&#125; items = self.__table.rows(row_keys) for item in items: result[item[0].decode("utf-8")] = self.__convert(item[1]) return result def query_all(self): items = self.__table.scan() result = &#123;&#125; for k, v in items: result[k.decode("utf-8")] = self.__convert(v) return resultdao = HBaseDao("SCORE")# result = dao.insert("row_key_5", &#123;"F:1": "李", "F:2": "述", "F:3": "昱"&#125;)# result = dao.insert("row_key_5", &#123;"F:1": "A", "F:2": "B", "F:3": "C"&#125;)# result = dao.insert_all(&#123;"row_key_6":&#123;"F:1":"Z", "F:2":"Y", "F:3":"X"&#125;, "row_key_7":&#123;"F:1":"Q", "F:2":"W", "F:3":"E", "F:4":"R"&#125; &#125;)# result = dao.delete_row("row_key_5")result = dao.delete_columns("row_key_4", "M:1")# result = dao.query("row_key_5")# result = dao.query("row_key_5", "row_key_6", "row_key_7")# result = dao.query_all()print(result) 更有用的方法是使用上下文管理器来管理batch，这样就不用手动发送数据了，即不再需要bat.send() 12345# 使用with来管理batchwith table.batch() as bat: bat.put("row_key_5", &#123;"F:1": "A", "F:2": "B", "F:3": "C"&#125;) bat.put("row_key_6", &#123;"F:1": "李", "F:2": "述", "F:3": "昱"&#125;) bat.put("row_key_7", &#123;"F:1":"Q", "F:2":"W", "F:3":"E", "F:4":"R"&#125;) 还可以删除数据 123456# 在batch中删除数据with table.batch() as bat: bat.put("row_key_5", &#123;"F:1": "A", "F:2": "B", "F:3": "C"&#125;) bat.put("row_key_6", &#123;"F:1": "李", "F:2": "述", "F:3": "昱"&#125;) bat.put("row_key_7", &#123;"F:1":"Q", "F:2":"W", "F:3":"E", "F:4":"R"&#125;) bat.delete("row_key_4") batch将数据保存在内存中，知道数据被send，第一种send数据的方法是显示地发送，即bat.send()，第二种send数据的方法是到达with上下文管理器的结尾自动发送。这样就存在一个问题，万一数据量很大，就会占用太多的内存。所以我们在使用table.batch()的时候要通过batch_size参数来设置batch的大小 1234# 通过batch_size参数来设置batch的大小with table.batch(batch_size=10) as bat: for i in range(16): bat.put('www.test&#123;&#125;.com'.format(i), &#123;'cf1:price': '&#123;&#125;'.format(i)&#125;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python I/O]]></title>
    <url>%2F2018%2F01%2F23%2Farticle%2Fpython%2Farticle-python_10%2F</url>
    <content type="text"><![CDATA[Python 中的 I/O输入与输出 Python I/O输出文件的读写123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python3# -*- coding: utf-8 -*-import osclass FileUtils(object): def __init__(self, **args): super(FileUtils, self).__init__() def read(self, file_name, mode='r'): """ :param file_name: file_path and file_name :param mode: open mode :return: file content lines array """ result = [] if not os.path.exists(file_name): print("没有 \"&#123;0&#125;\" 此文件...".format(file_name)) return None with open(file_name, mode, encoding="UTF-8") as f: for line in f.readlines(): result.append(line.strip()) return result def write(self, file_name, content, mode='w'): result = False with open(file_name, mode, encoding="UTF-8") as f: for line in content: f.write(line + "\r\n") result = True return result def truncate(self, file_name): with open(file_name, "w", encoding="UTF-8") as f: f.write("") return Truefu = FileUtils()# result = fu.read("/Users/smile/example.log")# result = fu.write("/Users/smile/example1.log", result, "a")result = fu.truncate("/Users/smile/example1.log")print(result) 文件的打开方式 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 文件对象的属性 文件对象属性 描 述 file.closed 表示文件已经被关闭，否则为False file.mode Access文件打开时使用的访问模式 file.encoding 文件所使用的编码 file.name 文件名 file.newlines 未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表 file.softspace 为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 异常处理]]></title>
    <url>%2F2017%2F12%2F31%2Farticle%2Fpython%2Farticle-python_09%2F</url>
    <content type="text"><![CDATA[Python 中的异常处理 Python中的异常处理try 的基本语法12345678910111213141516171819202122#!/usr/bin/env python3# -*- coding: utf-8 -*-import loggingdef division(x, y): if y == 0: raise ValueError("除数不能为 0") return x / ytry: print(division(4, 0))except ValueError as e: # raise print("除数为0, 计算终止....", e) logging.exception(e)else: print("计算正常结束....")finally: print("一切终归于平静....") ​ try: 是可能会出现异常的代码 ​ except: 是处理异常的代码 ​ else: 是没有出现异常执行的代码 ​ finally: 是无论如何都执行的代码 ​ raise: 是抛出自定义异常 ​ logging: 打印异常的堆栈信息 所谓异常处理, 分为两部分: 1. goto(跳转), 2. treat(应对) Python单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python3# -*- coding: utf-8 -*-import loggingclass MyDict(dict): def __init__(self, **kw): logging.info("init params ==&gt; %s" % str(kw)) super(MyDict, self).__init__(**kw) def __getattr__(self, item): try: return self[item] except KeyError: logging.error(r"MyDict no found [%s]" % item) raise KeyError(r"MyDict no found [%s]" % item) def __setattr__(self, key, value): self[key] = value#!/usr/bin/env python3# -*- coding: utf-8 -*-import logging, unittestfrom learn.MyDict import MyDictclass TestMyDict(unittest.TestCase): def setUp(self): # 测试方法执行前执行, 一般用来初始化环境(比如: 创建数据库连接) print('setUp...') def tearDown(self): # 测试方法执行后执行, 一般用来GC(比如: 关闭数据库连接) print('tearDown...') def test_init(self): d = MyDict(a=1, b='test') # assert 断言 self.assertEqual(d.a, 1) self.assertEqual(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = MyDict() d['key'] = 'value' self.assertEqual(d.key, 'value') def test_attr(self): d = MyDict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'], 'value') def test_keyerror(self): d = MyDict() with self.assertRaises(KeyError): # 判断抛出的异常是 KeyError value = d['empty'] def test_attrerror(self): d = MyDict() with self.assertRaises(AttributeError): # 测试未通过, 因为这里抛出的是KeyError value = d.empty 单元测试: 要求每一个分支都要覆盖到.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 面向对象]]></title>
    <url>%2F2017%2F12%2F30%2Farticle%2Fpython%2Farticle-python_08%2F</url>
    <content type="text"><![CDATA[Python 面向对象编程 面向对象OOP 类(Class) 对象(Object) 实例(Instance) 类: 是一个抽象的存在 实例: 是真实存在的类 对象: 是类的实例 好比说 门 就是一个类, 我的 屋门 就是门的一个实例. 我的屋门是白颜色的, 而且打开和关闭时会发出声响. 不管是 颜色, 还是打开和关闭 都是类赋予的属性和行为. 至于白颜色和打开和关闭时发出的声响是这个实例的具体表现. 对象: 包括了 类的属性和行为, 还有实例所都有的具体表现形式(比如: 白颜色, 打开和关闭时发出声响) 在面向对象的程序设计中, 首先要抽离出实体, 以及这个实体所拥有的属性和行为(方法). 面向对象的三大特点: 封装, 继承, 多态 封装123456789101112131415161718192021222324252627282930class Animal(object): def __init__(self, args): super(Animal, self).__init__() self.__name = args.get("name") self.age = args.get("age") def call(self): print("Animal(name:&#123;0&#125;, age:&#123;1&#125;) Call....".format(self.__name, self.age)); def setAnimalInfo(self, *, name, age): self.__name = name self.age = age def getAnimalInfo(self): return &#123;"name": self.__name, "age": self.age&#125; def __str__(self): # 重写父类方法 return "Animal(name:&#123;0&#125;, age:&#123;1&#125;)".format(self.__name, self.age)pig = Animal(&#123;&#125;)pig.setAnimalInfo(name="tom", age=2)pig.call()pig.age = 3print(pig.age)print(pig._Animal__name) # 不建议这样访问# print(pig.__name) # AttributeError: 'Animal' object has no attribute '__name'pig.__name = "jack" # 这么写是错误的, 虽然Python没有限制print(pig.__name) # 实际上就是给 pig 绑了一个新的属性pig.call() 所谓封装, 就是将类的属性设为私有, 然后开放属性的get, set方法. 这样会提高程序的健壮性(比如set时, 验证实参是否合法) 因为构造方法(init(self, args))中, 存在必选参数, 所以在初始化实例时 pig = Animal({}) 实际上私有属性, 在实例化对象时, 就已经改了变量名, 所以才有的 AttributeError: &#39;Animal&#39; object has no attribute &#39;__name&#39; 的错误信息 pig.__name = &quot;jack&quot; 就像当于给pig实例, 重新绑定了新的属性(这样写虽然语法没有错, 但不建议这样写. 就像某件事, 没有触犯法律, 但受到道德的谴责.) 继承class Animal(object) Animal 继承自 object, 1234567891011121314151617181920212223242526272829303132333435363738394041class Dog(Animal): def __init__(self, args): super(Dog, self).__init__(args) def call(self): # print("Dog(name:&#123;0&#125;, age:&#123;1&#125;) wang....".format(super().__name, super.age)); print("Dog(name:&#123;0&#125;, age:&#123;1&#125;) wang....".format(super(Dog, self).getAnimalInfo().get("name"), super(Dog, self).getAnimalInfo().get("age"))); def __str__(self): # 重写父类方法 # return "Dog(name:&#123;0&#125;, age:&#123;1&#125;)".format(super().__name, super.age) return "Dog(name:&#123;0&#125;, age:&#123;1&#125;)".format(super(Dog, self).getAnimalInfo().get("name"), super(Dog, self).getAnimalInfo().get("age"))class Cat(Animal): def __init__(self, args): super(Cat, self).__init__(args) def call(self): # print("Cat(name:&#123;0&#125;, age:&#123;1&#125;) miao....".format(self.__name, self.age)); print("Cat(name:&#123;0&#125;, age:&#123;1&#125;) miao....".format(super(Cat, self).getAnimalInfo().get("name"), super(Cat, self).getAnimalInfo().get("age"))); def __str__(self): # 重写父类方法 # return "Cat(name:&#123;0&#125;, age:&#123;1&#125;)".format(self.__name, self.age) return "Cat(name:&#123;0&#125;, age:&#123;1&#125;)".format(super(Cat, self).getAnimalInfo().get("name"), super(Cat, self).getAnimalInfo().get("age"))dog = Dog(&#123;"name": "lucy", "age": 2&#125;)cat = Cat(&#123;"name":"lola", "age":1&#125;)dog.call()cat.call()print("pig is Animal", isinstance(pig, Animal))print("dog is Dog", isinstance(dog, Dog))print("cat is Cat", isinstance(cat, Cat))print("dog is Animal", isinstance(dog, Animal))print("cat is Animal", isinstance(cat, Animal)) 在子类中, 获取父类的引用 super(Dog, self). 而在子类中要想拿到父类的属性, 只能通过父类中提供的开放接口, 来实现了. 多态从上面的程序中可以看出, Animal重写了他的父类的str方法, Cat和Dog也重写了这个方法. 有继承和方法重写, 自然就有多态了. 1234567891011def getAnimal(animal): print(animal)getAnimal(pig)getAnimal(dog)getAnimal(cat)# Animal(name:tom, age:3)# Dog(name:lucy, age:2)# Cat(name:lola, age:1) 虽传入的都是 Animal类, 但执行的却有着不同的行为. 这就是多态(^_^) 判断对象类型1234567891011121314&gt;&gt;&gt; type(123) == type(456)True&gt;&gt;&gt; type("123") == 'str'False&gt;&gt;&gt; type("123") == strTrue&gt;&gt;&gt; isinstance(1, (str, int))True&gt;&gt;&gt; isinstance(1, (str, int, float))True&gt;&gt;&gt; isinstance(1.0, (str, int, float))True&gt;&gt;&gt; isinstance('1.0', (str, int, float))True 获取对象的所有方法及属性12345print(dir(pig))print(dir(dog))# ['_Animal__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__name', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'call', 'getAnimalInfo', 'setAnimalInfo']# ['_Animal__name', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__int__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'call', 'getAnimalInfo', 'setAnimalInfo'] 类似反射的东西123456789101112131415161718192021# hasattr() 判断对象中是否有指定属性或方法# getattr() 获取对象中指定的属性或方法的引用# setattr() 向对象中添加指定的属性或方法print(getattr(pig, "__name") if hasattr(pig, "__name") else "404")print(getattr(dog, "__name") if hasattr(dog, "__name") else "404")if hasattr(cat, "__name"): # 判断cat对象中, 是否有'__name'属性 print(cat.__name)else: setattr(cat, "__name", "tom") # 向cat对象绑定'__name'属性, 并向该属性赋值print(cat.__name) # 输出刚刚绑定的'__name'属性的值getattr(cat, "call")() # 获取cat对象的call方法, 进行调用def eat(): print("eat.... ing.....")setattr(cat, "eat", eat) # 是将方法绑定到了cat这个对象上, 而非类上. 所以新创建的类, 没有eat方法cat.eat() 实例属性和类属性实例属性: 就相当于Java类中的普通属性 类属性: 就相当于是Java中的静态属性 1234567891011121314151617class Plant(object): name = "植物" def __init__(self, *args): super(Plant, self).__init__() if len(args) &gt; 0: self.name = args[0] def __str__(self): return Plant.name;pl = Plant("绿萝")print(pl) # 类属性: 植物print(pl.name) # 实例属性的优先级高于类属性, 所以输出实例属性: 绿萝delattr(pl, "name") # 删除实例属性print(pl.name) # 因为实例属性中没有 name 了, 所以输出类属性: 植物 Python内置的@property装饰器就是负责把一个方法变成属性调用. 把一个getter方法变成属性，只需要加上@property就可以了, 此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值 12345678910111213141516171819202122232425262728class Lotus(Plant): @property def colour(self): # 隐藏 _colour 属性, 对外看到的只是 colour return self._colour @colour.setter def colour(self, value): print("Assignment ing...") self._colour = value @property def age(self): return 54lotus = Lotus()lotus.colour = "橙红色" # 调用了 colour set方法print(lotus.colour)print(lotus.age)print(dir(lotus))print(getattr(lotus, "colour"))setattr(lotus, "colour", "粉红色") # 调用了 colour set方法print(getattr(lotus, "_colour"))setattr(lotus, "_colour", "艳红色") # 没有调用colour set方法print(lotus.colour) 在测试环境下, 我们可以看到 lotus 对象中有colour 和 _colour 两个属性, 但实际我们定义的_colour属性, 在面向其他对象时, 是被隐藏的, 所以在对@property的实例属性操作的时候, 属性很可能不是直接暴露的，而是通过getter和setter方法来实现的 上面的colour是可读写属性，而age就是一个只读属性 Python的多重继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Book(object): def __init__(self, name): # super(Book, self).__init__() self.name = name def getName(self): return self.nameclass Literature(object): def __init__(self, author): # super(Literature, self).__init__() self.author = author def getAuthor(self): return self.authorclass Biography(object): def __init__(self, heroName): # super(Biography, self).__init__() self.heroName = heroName def getHeroName(self): return self.heroNameclass Youth(Book, Literature, Biography): def __init__(self, name, author, heroName): Book.__init__(self, name) Literature.__init__(self, author) Biography.__init__(self, heroName) def getInfo(self): return "书名: &#123;0&#125;, 作者: &#123;1&#125;, 主人公: &#123;2&#125;".format( self.getName(), self.getAuthor(), self.getHeroName())book = Youth("青春", "J.M.库切", "约翰")print(book.getName())print(book.getAuthor())print(book.getHeroName())print(book.getInfo())# 青春# J.M.库切# 约翰# 书名: 青春, 作者: J.M.库切, 主人公: 约翰 Object中常用到的类__str__() 和__repr__()__str__()有点类似Java里的toString方法, 就是在 str(object) 时调用的方法 __repr__() 和 __str__()的功能差不多, 在控制台直接调用对象时, 会调用__repr__()方法 两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。 1234567891011121314class CustomMade(object): def __str__(self): return "我被主人改了toString方法" def __repr__(self): return "我也被主人改了toString方法" cm = CustomMade()print(cm) # 我被主人改了toString方法&gt;&gt;&gt; cm = CustomMade()&gt;&gt;&gt; cm我也被主人改了toString方法 __item__() 和 __next__()__item__() 返回一个迭代对象 --next__() 迭代这个对象时, 所执行的方法(有点像生成式) 1234567891011121314151617181920class CustomMade(object): def __init__(self): super(CustomMade, self).__init__() self.index = 0 def __iter__(self): return self def __next__(self): self.index += 1 if self.index &gt; 100: raise StopIteration() return self.indexcm = CustomMade()for x in cm: print(x)# 1 2 3 4 ... 100 __getitem__()__getitem__() 是让我们自己定义的类, 拥有索引和切片的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445class CustomMade(object): def __getitem__(self, item): if isinstance(item, int): if item &gt; 50 or item &lt; -50: raise IndexError() else: if item &lt; 0: item = 50 + item index = 2 for x in range(item): index += 2 return index if isinstance(item, slice): start = item.start stop = item.stop step = item.step if start is None: start = 0 if step is None: step = 1 if start &lt; 0: start = 50 + start if stop &lt; 0: stop = 50 + stop result = [] index = 2 skip = -1 for x in range(stop): if x &gt;= start: skip += 1 if skip % step == 0: result.append(index) index += 2 return resultcm = CustomMade()print(cm)for x in cm: print(x)print(cm[1]) # 4print(cm[:10:2]) # [2, 6, 10, 14, 18] __getattr__()__getattr__() 给未绑定的属性或方法一个默认的返回值 1234567891011121314151617class Chain(object): def __init__(self, method='GET', path=''): super(Chain, self).__init__() self._path = path self._method = method def __str__(self): return "&#123;0&#125; &#123;1&#125;".format(self._method, self._path) def __getattr__(self, path): if path == "user": return lambda x: Chain(self._method, "&#123;0&#125;/&#123;1&#125;/&#123;2&#125;".format(self._path, path, x)) return Chain(self._method, "&#123;0&#125;/&#123;1&#125;".format(self._path, path))print(Chain("POST").status.user("yuchen352416").timeline.list)# POST /status/user/yuchen352416/timeline/list __call__()__call__() 是实例默认调用的方法 1234567891011class Student(object): def __init__(self, name): super(Student, self).__init__() self._name = name def __call__(self, *args, **kw): print("Student name is %s" % self._name)s = Student('Jack')s() # Student name is Jack 枚举与单例12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python3# -*- coding: utf-8 -*-from enum import Enum, uniqueMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))# 这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量for k, v in Month.member_map_.items(): print(k, v, v.value)# value属性则是自动赋给成员的int常量，默认从1开始计数。print(Month.Jan.value)print(Month(2))@uniqueclass Weekday(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6print(Weekday(2))# 自定义value# @unique装饰器可以帮助我们检查保证没有重复值。# 单例class DateUtil(Enum): class DateUtil(object): def __str__(self): return "单例...." instance = DateUtil()print(DateUtil.instance.value) 动态生成类与实例type()12345678910111213# type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类def fn(self, name): self._name = namedef hell(self): print("Hello %s" % self._name)Hello = type("Hello", (object,), &#123;"hello": hell, "setName": fn&#125;)hello = Hello()hello.setName("Jack")hello.hello() # Hello Jack# 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class metaclass123456789101112131415# 除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)class MyList(list, metaclass=ListMetaclass): pass# 当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建L = MyList()L.add(1)print(L) # [1] __new__()方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法和属性的集合。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 高级函数]]></title>
    <url>%2F2017%2F12%2F29%2Farticle%2Fpython%2Farticle-python_07%2F</url>
    <content type="text"><![CDATA[Python 中函数的一些高级用法 在熟悉了自定义函数和函数中使用到的参数(必选参数, 默认参数, 可变参数, 关键字参数, 命名关键字参数), 以及由函数返回值引伸出的递归和装饰器后, 让我们继续前行. Python 高阶函数mapmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回123456def func(x): return x * xm = map(func, [2, 3])print(m)for x in m: print(x) map函数, 就有点类似一个加工厂, func 就像是加工规则, [2, 3] 就像是加工原料, 每个原料加工后, 就成了map的返回值[4, 9] reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算123456from functools import reducedef func(x, y): return x + ys = reduce(func, [1, 2, 3, 4, 5]) # 15# s = func(func(func(func(1, 2), 3), 4), 5) # 15 reduce函数, 就像是个面包机, [1, 2, 3, 4, 5] 就像是事先要准备的原料 [面粉,鸡蛋, 牛奶, 糖] 而func, 就像是向面包机里加的动作 最后的面包机中的热腾腾的面包, 就是返回结果了.^_^ filterfilter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。12345678910111213def remove_ood(x): if x % 2 == 0: return True else: return Falsearr = list(range(1, 10))envn = filter(remove_ood, arr)print(even) # &lt;filter object at 0x10a444630&gt;for x in envn: print(x)# 2 4 6 8 filter函数 就是把传入集合中的元素, 按照指定规则分离. 有点像是做奶油前要从鸡蛋中去出蛋黄, 留下蛋清. (^_^) sortedsorted()函数就可以对list进行排序12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如:12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] 其实还可以这样玩12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo'] 这样 排序就忽略了数组中的字符的大小写 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 数组的反转 匿名函数关键字lambda表示匿名函数，冒号前面的x表示函数参数。1print(reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])) # 15 lambda 与 : 之间是匿名函数的入参 偏函数所谓偏函数，其实就是将一个已知参数和函数进行绑定，生成一个新的函数 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去12def int2(x, base=2): return int(x, base) 这样，我们转换二进制就非常方便了：1234&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 functools.partial 就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 Python 高级特性切片切片是Python提供处理Iterable类型数据的一个工具.1234567891011121314151617181920&gt;&gt;&gt; L = list(range(100))# 前10个元素&gt;&gt;&gt; L[:10] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# 后10个元素&gt;&gt;&gt; L[-10:] # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]# 前11-20个元素&gt;&gt;&gt; L[10:20] # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]# 前10个数，每两个取一个&gt;&gt;&gt; L[:10:2] # [0, 2, 4, 6, 8]# 倒数 第3个~倒数第5个&gt;&gt;&gt; L[-5:-2][::-1] # [97, 96, 95]&gt;&gt;&gt; 'ABCDEFG'[:3] # 'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2] # 'ACEG'&gt;&gt;&gt; 'ABC'[::-1] # 'CBA' Iterable[起始位置=0:截至位置=len(Iterable):步长=1] 迭代我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration） 12345678910111213d = &#123;'a': 1, 'b': 2, 'c': 3&#125;for k in d: print(k) # a b cfor v in d.values(): print(v)# 1 2 3for k, v in d.items(): print(k, '-', v)# a - 1 b - 2 c - 3 如何判断一个对象是可迭代对象呢？1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 迭代tuple123for x, y in [(1, 1), (2, 4), (3, 9)]: print('&#123;0&#125;-&#123;1&#125;'.format(x, y))# 1-1 2-4 3-9 列表生成式从一定意义上来说, 列表生成式可以做到的, 用map()函数也可以做到.但列表生成器更容易, 更直观. 我现在需要一个数组2次方后的一个数组.12345L = [1, 2, 3, 4, 5]L1 = map(lambda x: x * x, L)L2 = [x * x for x in L]print(L1) # object.mapprint(L2) #[1, 4, 9, 16, 25] 其实, 还可以这样^_^123t = [1, 2, 3]l = [t[i] * t[i + 1] for i in range(len(t) -1)]print(l) # [2, 6] 生成器在Python中，这种一边循环一边计算的机制，称为generator(生成器)12g = (x * x for x in range(10))print(g) # &lt;generator object &lt;genexpr&gt; at 0x1101431a8&gt; 和列表生成式不同的是, 生成器返回的是一个Iterable, 而列表生成式返回的是一个数组 generator: 存储的是计算规则, 并没有真实的数据. 遍历时, 每次返回的数据, 都是按照所存储的计算规则计算出的 123456789def odd(): n = 1 while True: yield n n += 2o = odd()print(next(o)) # 1print(next(o)) # 3 odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。 最后附上一位大神用generator实现的杨辉三角1234567def triangles(): t = [1] while True: yield t t= [t[i] + t[i-1] for i in range(1,len(t))] t.insert(0,1) # 第一位始终为 1 t.append(1) # 最后一位始终为 1 迭代器凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable, 但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python 模块 这是我项目中各文件的路径.我在hello.py中希望引用我web模块下的utils中的函数12345from web.utils import reverseprint(reverse("123"))import web.utilsweb.utils.welcome("Tom")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 自定义函数]]></title>
    <url>%2F2017%2F12%2F28%2Farticle%2Fpython%2Farticle-python_06%2F</url>
    <content type="text"><![CDATA[Python 中自己定义函数 在熟悉了Python中常用的一些内置函数, 那接下来我们定义一个自己的函数吧 12def add(x, y): return x + y 函数函数语法123def functonname(parameters): ... return result 定义空函数12def nop(): pass 实际上 pass 是用来作为占位符的. 比如现在还没想好怎么写函数的代码, 就可以先放一个pass, 让其他代码可以运行起来. 函数也是Object1234567def pow(x, y): result = 1 for i in range(0, y): result = result * x return resultprint(pow) #&lt;function pow at 0x104147e18&gt; 函数也是内存中的一块区域, 函数名指向这块区域.123fn = powprint(fn) #&lt;function pow at 0x104147e18&gt;print(fn(2, 10)) #1024 参数 必选参数 默认参数 可变参数 关键字参数 命名关键字参数 必选参数12345678def pow(x, y): result = 1 for i in range(0, y): result = result * x return resultt = pow(2, 3)print(t) # 8 上面函数中, 需要两个参数分别是 x, y. 这两个参数都是必选参数, 缺一不可.pow函数中 x 为底数, y 为指数, 现在我想让指数默认为 2 默认参数12345678def pow(x, y = 2): result = 1 for i in range(0, y): result = result * x return resultt = pow(2)print(t) # 4 设, 我要求多个数的和. 具体有多个参数, 我也不知道 可变参数12345678910111213141516def sum_1(numbers): s = 0 for x in numbers: s += x return sdef sum_2(*numbers): s = 0 for x in numbers: s += x return sarr = [1, 2, 4]print(sum_1(arr))print(sum_2(1, 2, 4))print(sum_2(*arr)) 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict12345678910111213def person(name, age, **kw) : # ** =&gt; dict print("kw tyep is", type(kw)) if "city" in kw : print("city :", kw["city"]) if "job" in kw: print("job :", kw.get("job")) print("name:", name, ", age:", age, ", other:", kw)person("Jion", 18, city = "Beijing")person(name = "Tom", city = "Beijing", age = 17)extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;person("Jion", 18, **extra) 命名关键字参数如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数 12def person(name, age, *, city, job): print(name, age, city, job) 命名关键字参数需要一个特殊分隔符 * ，* 后面的参数被视为命名关键字参数。12&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了.1234567891011121314151617def person(name, age, *, city = "Beijing", job): # 要限制关键字参数的名字, 就要用到 "命名关键字参数" # * 后的参数, 被视为"命名关键字参数" print(name, age, city, job)person("Jack", 24, job = "Engineer")x = &#123;"city":"Shanghai", "job":"Engineer"&#125;person("Jack", 23, **x)person("Jack", 23, city = "Beijing", job = "Engineer")def person(name, age, *args, city, job): print(name, age, args, city, job)x = &#123;"A":1, "B":2, "C":3&#125;# 当实参为 *x 时, 会将实参中的key以tuple(元组)的形式, 传递到方法内# person("Jack", 23, *x, city = "Beijing", job = "Engineer") # Jack 23 ('A', 'B', 'C') Beijing Engineer# 当实参为 x 时, 会将实参的整体内容做为tuple(元组)的一个元素, 传递到方法内person("Jack", 23, x, city = "Beijing", job = "Engineer") # Jack 23 (&#123;'A': 1, 'B': 2, 'C': 3&#125;,) Beijing Engineer 返回值返回常用类型1234567def abs(x): if(x &gt;= 0): return x else: retrun -xprint(abs(-1)) #1 return 类似出栈操作, return之后的语句则不被执行 返回多个值123456def show(x, y, z): return x * y * z, x + y + zx = show(2, 3, 4)print(x[0], x[1]) #24 9print(x) #(24, 9) 当函数返回多个值时, 实际上是把多个需要返回的值, 封装成一个tuple 返回函数刚刚说过, 函数也是一个Object, 所以也可以作为返回值进行返回 递归123456789def trim(s): if (s == ''): return '' if (ord(s[:1]) == 32): return trim(s[1:]) elif (ord(s[-1:]) == 32): return trim(s[:-1]) else: return s 这是一个去除字符串前后空格的函数, 首先检测字符串的第一位是不是空格, 如果是去掉第一位, 再次检查新字符串的第一位 直至不是后, 检查字符串的最后一位, 如果是, 则去掉最后一位, 再次检测新字符串的最后一位.直到最后一位,不再是空格. 闭包12345678910def make_adder(addend): def adder(augend): return augend + addend return adderp = make_adder(23)q = make_adder(44)print(p(100)) #123print(q(100)) #144 闭包: 可以形象的把它理解为一个封闭的包裹，这个包裹就是一个函数，当然还有函数内部对应的逻辑，包裹里面的东西就是自由变量，自由变量可以在随着包裹到处游荡。当然还得有个前提，这个包裹是被创建出来的。在通过Python的语言介绍一下，一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。 1234567def func(name): def inner_func(age): print 'name:', name, 'age:', age return inner_funcbb = func('the5fire')bb(26) # &gt;&gt;&gt; name: the5fire age: 26 这里面调用func的时候就产生了一个闭包——inner_func,并且该闭包持有自由变量——name，因此这也意味着，当函数func的生命周期结束之后，name这个变量依然存在，因为它被闭包引用了，所以不会被回收。 1234567891011121314def hellocounter (name): count = 0 def counter(): # 如果不加 nonlocal 会报错 # UnboundLocalError: local variable 'count' referenced before assignment nonlocal count count += 1 print ('Hello &#123;0&#125;, &#123;1&#125; access!'.format(name, count)) return counterhello = hellocounter('ysisl')hello()hello()hello() 在闭包函数内, 可以直接访问父函数作用域下的变量, 但不可以修改.python3里面,引入了一个关键字:nonlocal,这个关键字是干什么的? 就是告诉python程序, 我的这个count变量是再外部定义的, 你去外面找吧. 然后python就去外层函数找, 然后就找到了count = 0 这个定义和赋值, 程序就能正常执行了. 装饰器装饰器: 是对闭包的一种实际运用的场景. 12345678910111213141516def makebold(fn): def wrapped(): return "&lt;b&gt;" + fn() + "&lt;/b&gt;" return wrappeddef makeitalic(fn): def wrapped(): return "&lt;i&gt;" + fn() + "&lt;/i&gt;" return wrapped@makebold@makeitalicdef hello(): return "hello world"print hello() # &lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt; 相当于 makebold(makeitalic(hello())) 123456789101112131415161718192021222324252627import timedef timecost(func): def wrapper(*args, **kw): def fn(*args, **kw): start = int(time.time()) print(&quot;Call &#123;0&#125;() Before [&#123;1&#125;]&quot;.format(func.__name__, time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(int(time.time()))))) func(*args, **kw) print(&quot;Call &#123;0&#125;() After [&#123;1&#125;]&quot;.format(func.__name__, time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(int(time.time()))))) end = int(time.time()) print(&quot;Run Cost Time &#123;0&#125;s&quot;.format(end - start)) return fn(*args, **kw) return wrapper@timecostdef now_datetime(format): now = int(time.time()) print(time.strftime(format, time.localtime(now)))now_datetime(&quot;%H:%M:%S&quot;)# Call now_datetime() Before [2018-01-15 00:24:17]# 00:24:17# Call now_datetime() After [2018-01-15 00:24:17]# Run Cost Time 0s# 在方法前后加入自己想要的内容, 哈哈, 这就是传说中的AOP吗?]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 内置函数]]></title>
    <url>%2F2017%2F12%2F27%2Farticle%2Fpython%2Farticle-python_05%2F</url>
    <content type="text"><![CDATA[Python 中常用到的一些内置函数 熟悉了Python中的控制语句后, 就可以进一步探索Python了. Python 常用的内置函数所谓内置函数, 是不用导入其他模块, 就可以直接使用的函数 range()它生成一个等差级数链表 range( [起始值, 0], &lt;截止值&gt;, [步长, 1] )1range(3, 10, 3) # 3, 6, 9 list()从可迭代（对象）中创建列表 list( )1list(range(3, 10, 3)) # [3, 6, 9] chr()返回传入ASCII码对应的字符 chr( )1chr(65) # A ord()返回传入字符对应的ASCII码值 ord( )1ord('A') # 65 len()返回传入集合长度 len( &lt;集合&gt; )1len([1, 3, 5]) # 3 input()接收控制台的输入内容 input( [“提示信息”] )1input("请输入您的身高:") float()将传入数据, 转为 float类型 float( ) raise ValueError12float(1) # 1.0float("1.9") # 1.9 str()将传入数据, 转为字符串 str( )1str(&#123;"A":1, "B":2&#125;) # "&#123;'A': 1, 'B': 2&#125;" int()将传入数据, 转为 int 类型 int( ) raise ValueError12int(1.9) # 1int("1.9") # ValueError isinstance()判断数据是否指定类型 isinstance( , )12x = 1.0isinstance(x, float) # True type()返回传入数据的类型 type( )1type(1) == int # True Python 字符集bytes 类型数据123456x = b'A' # bytes 类型数据 y = 'A'print('x =', x, '\t' ,type(x)) # &lt;class 'bytes'&gt;print('y =', y, '\t' ,type(y)) # &lt;class 'str'&gt;z = ord(x) print(z) # 65 字符编码1234print('A'.encode('ASCII'))print('森'.encode('GBK')) # b'\xc9\xad'print('森'.encode('GB2312')) # b'\xc9\xad'print('森'.encode('UTF-8')) # b'\xe6\xa3\xae' ASCII码 范围 [0, 127]GBK 和 GB2312 都是用两个字节表示UTF-8 用三个字节表示 123456789101112131415161718x = b'\x41'print(x) # b'A'print(x.decode("ASCII")) # Ax = b'\xc9\xad' # =&gt; 11001001 10101101print(x.decode("GB2312")) # 森print(x.decode("GBK")) # 森x = b'\xe6\xa3\xae' # =&gt; 11100110 10100011 10101110print(x.decode("UTF-8")) # 森print(len('ABC')) # 3print(len('森A')) # 2x = b'\xc9\xad'print(x) # b'\xc9\xad'print(x.decode("GBK")) # 森print(len(x)) # 2# 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。print(len('森'.encode('utf-8'))) # 3print(len('森A'.encode('utf-8'))) # 4 Python 字符串格式化1234567891011121314151617s = 'Hello %s' % ('World!')print(s)# %d 表示 整数# %f 表示 浮点数# %s 表示 字符串# %x 表示 十六进制整数# s = 'Age: %s. Gender: %s' % (25, True)# s = 'Age: %d. Gender: %s' % (25, True)# s = 'Age: %f. Gender: %s' % (25, True)s = 'Age: %x. Gender: %s' % (25, True) # 十进制25传入, 会转化一次, 变为十六进制的 19 print(s)s = 'Growth rate: %d%%' % (7) # 在使用格式化占位符的字符串中, 用 %% 来表示一个 % print(s)# 使用format方法, 格式化输出s = 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.2f&#125;%'.format('小明', 17.125)print(s)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 控制语句]]></title>
    <url>%2F2017%2F12%2F26%2Farticle%2Fpython%2Farticle-python_04%2F</url>
    <content type="text"><![CDATA[Python 中的控制语句 熟悉了Python中的各种运算符之后, 接下来要进一步了解Python了 控制语句if 语句 单分支 if 双分支 if 多分支 if 单分支 if12if x &gt;= 0: print("x 为自然数") 需要注意: 关系表达式后面要跟冒号, 而 if 条件成立执行的语句, 用 tab 撮行表示, 而且没有 {} 双分支 if1234if x == 1: print("条件成立...")else: print("条件不成立...") 多分支 if123456if x == 1: print("状态尚可...")elif x == 2: print("状态极佳...")else: print("状态不佳...") for 语句12for x in [1, 2, 3, 4]: print(x) for 语句 是用来遍历 Iterable(可迭代对象)的 while 语句123456789x = 0while True: x += 1; if x % 2 == 0: print(x) continue if x % 3 == 0: print(x) break continue 跳回循环开始处break 跳出循环 switch 语句123456789101112131415161718int x = 0;switch (x) &#123; // Java 的语法 case 0: &#123; System.out.println("0"); break; &#125; case 1: &#123; System.out.println("1"); break; &#125; case 2: &#123; System.out.println("2"); break; &#125; default: &#123; System.out.println("9"); &#125;&#125; 很遗憾, Python 好像没有 switch 语句, 但也不是没有变通之道 12345678910111213# 方法 1def func(x): return &#123; 'a': 1, 'b': 2 &#125;.get(x, 9) # 方法 2result = &#123; 'a': lambda x: x * 5, 'b': lambda x: x + 7, 'c': lambda x: x - 2&#125;[value](x)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 各种运算符]]></title>
    <url>%2F2017%2F12%2F25%2Farticle%2Fpython%2Farticle-python_03%2F</url>
    <content type="text"><![CDATA[Python 中的各种运算符 在掌握了怎么用Python定义变量和Python常用的数据类型后, 我们就可以继续探索Python世界了. 运算符算术运算符 运算符 描述 实例 + 加 1 + 2 =&gt; 3 - 减 3 - 2 =&gt; 1 * 乘 2 * 3 =&gt; 6 / 除 6 / 2 =&gt; 3 // 整除 7 // 2 =&gt; 3 % 模除 7 % 2 = 1 ** 幂 2 ** 3 = 8 关系运算符 运算符 描述 实例 == 等于 1 == 2 =&gt; False != 不等 3 != 2 =&gt; True &lt;&gt; 不等 2 &lt;&gt; 3 =&gt; True &gt; 大于 6 &gt; 2 =&gt; True &lt; 小于 7 &lt; 2 =&gt; False &gt;= 大于等于 7 &gt;= 2 = True &lt;= 小于等于 2 &lt;= 3 = True 赋值运算符 运算符 描述 实例 = 赋值 x = 1 += 加赋值 x += 1 -= 减赋值 x -= 1 *= 乘赋值 x *= 2 /= 除赋值 x /= 2 //= 整除赋值 x //= 2 %= 模除赋值 x %= 2 **= 幂赋值 x **= 3 位运算符 运算符 描述 实例 &amp; 与运算 5 &amp; 2 &#124; 或运算 5 &#124; 2 ~ 取反运算 ~7 ^ 异或运算 7 ^ 3 &lt;&lt; 左移运算 1 &lt;&lt; 2 &gt;&gt; 右移运算 7 &gt;&gt; 1 123456print( 5 &amp; 2 ) # 00000101 and 00000010 =&gt; 00000000 =&gt; 0print( 5 | 2 ) # 00000101 or 00000010 =&gt; 00000111 =&gt; 7 print( 7 ^ 3) # 00000111 xor 00000011 =&gt; 00000100 =&gt; 4print(1 &lt;&lt; 2) # 00000001 &lt;&lt; 2 =&gt; 00000100 =&gt; 4 print(7 &gt;&gt; 1) # 00000111 &gt;&gt; 1 =&gt; 00000011 =&gt; 3print(~7) # -x - 1 =&gt; -8 涉及到的一些概念1. 源码: 是指由 0 和 1 组成的二进制数.(先低后高存储)2. 无符号位数: 是指将源码的所有有效位数, 都用来表示数值(比如 “0000 0001” 这是一个8位的二进制数, 可以表示数的范围就是[0, 255])3. 有符号位数: 是指用源码的第一位表示符号位(1 表示负数, 0 表示正数), 其余的位数来表示数值(比如”0000 0001” 这是一个8位的二进制数, 可以表示数的范围就是[-128, 127])4. 原码: 是指用有符号位数表示的二进制数5. 反码: 正数的反码是它本身, 负数的反码是除符号位外的其他位取反得到的(比如 -7的原码是 10000111, 反码就是 11111000)6. 补码: 正数的补码是它本身, 负数的补码是在反码的基础上加 1(比如 -7 的反码是 11111000, 那补码就是 11111001) ~取反运算符, 是将数值的补码进行取反 ~7 =&gt; ~(0000 0111) =&gt; 1111 1000 =&gt; 1000 0111(反码) =&gt; 1000 1000(补码) =&gt; -8同理 ~(-8)∵ -8 =&gt; 1000 1000(原码) =&gt; 1111 0111(反码) ==&gt; 1111 1000(补码)∴ ~(-8) =&gt; ~(1111 1000) =&gt; 0000 0111 =&gt; 7 逻辑运算符 运算符 描述 实例 not 非 not True and 与 True and False or 或 True or False 成员运算符 运算符 描述 实例 in 存在 1 in range(10) not in 不存在 1 not in range(2, 10) 身份运算符 运算符 描述 实例 is 是否相同引用 x is y is not 是否不同引用 x is not y 运算符的优先级 描述 运算符 ** 指数 (最高优先级) ~ 按位翻转 * / % // 乘, 除, 模除和整除 + - 加法, 减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 与运算 ^ &#124; 或运算符和异或运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 关系运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 变量与数据类型]]></title>
    <url>%2F2017%2F12%2F24%2Farticle%2Fpython%2Farticle-python_02%2F</url>
    <content type="text"><![CDATA[Python 的变量与数据类型 在迈过HelloWorld的大门后, 正式开始了解Python 变量变量定义当看到Python的变量定义方式时, 让我有一点意外.即没有变量的类型说明符, 也没有定义变量的标志符(如: JavaScript的var, VB的Dim)1x = 1 这样, 就定义一个变量 x 这个变量的类型, 取决于变量指向的值. 行尾不能加分号, 让我也是纠结了好一会儿, 不过还是要入乡随俗的, 慢慢习惯了就好. 数据类型基本数据类型基本数据类型包括 int, float, str, bool 测试基本数据类型:12345678i = 1f = 2.0s = "jack"b = Trueprint("i type", type(i))print("f type", type(f))print("s type", type(s))print("b type", type(b)) 执行结果: 局部变量123456789x = 50def func(x): print('x is', x) x = 2 # 这里修改的是局部变量 print('Changed local x to', x)func(x)print('x is still', x) 执行结果: x is 50 Changed local x to 2 x is still 50 fun(x) 方法中, x 作为形参传进方法体中进行运算, 方法体中认为 x 是局部变量 全局变量12345678910x = 50def func(): global x print('x is', x) x = 2 # 这时修改的是全局变量 print('Changed global x to', x)func()print('Value of x is', x) 输出结果: x is 50 Changed global x to 2 Value of x is 2 x 显然未在func() 方法中, 故用 global 声明 x 为全局变量, 使用外面的x变量 常用的数据类型 list tuple set dictionarylist (数组)123arr = [1, "jack", 9.7, True]print(arr)print(type(arr)) 执行结果: 同样我们也可以定义一个二维数组:12arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]print(arr[1][1]) # 5 当数组中的内容不固定时, 我们还可以动态操作 list:123456789arr = []arr.append("A")arr.append("B")arr.append("C")arr.insert(1, "X")arr.remove("B")arr.pop()arr.pop(0)print(arr) append: 将在数组末尾添加元素insert: 将在指定位置添加元素remove: 删除指定元素pop: 删除指定位置的元素, 如果没有指定位置, 则删除末尾元素 tuple(元组)tuple和list非常类似，但是tuple一旦初始化就不能修改1234classmates = ('Michael', 'Bob', 'Tracy')print('classmates =', classmates)print('classmates[0] =', classmates[0])classmates[0] = "Jack" # TypeError: 'tuple' object does not support item assignment 但是当tuple中含有 list, set, dictionary时, 情况就不一样了123classmates = ('Michael', ["a", "b"])classmates[1].append("c")print('classmates =', classmates) 执行结果: classmates = (‘Michael’, [‘a’, ‘b’, ‘c’]) 看上去 classmates 改变了, 但实际上 classmates 是没有变的. classmates[1]指向的list的指针是没有变的, 改变的是指针指向的list set(集合)set有一个特性, 就是元素的内容是唯一的, 还有set和tuple一样, 只可以添加不可变的值123456789101112131415s = set([1, 2, 3]) # 初始化Set时, 只能接收lists.add(4)s.add((4, 5)) # set 只可以添加不可变的值s.add((4, 5)) # 不会重复添加s.add((4, 5, 6))x = "ABC"s.add(x)x = "XYZ" # 虽然 x 改变了指针指向, 但set中原来添加的并不是变量x, 而是x所指向的"ABC"# s.add([1, 2, 5]) # set 不能添加可变的元素s.remove(1)s.remove((4, 5, 6))# s.remove(5) # KeyError: 5print(s) 执行结果: dictionary(字典)1234567891011121314151617181920dictionary = &#123; "name" : "小明", "age" : 23, "phone":"18733774869", "age" : 24 # 这样是可以的, 新值会覆盖旧值, 但实际情况中这样没有意义&#125;dictionary["age"] = dictionary["age"] + 1 # 修改dictionary中指定key的值dictionary["address"] = "北京, 丰台区" # 向dictionary中添加新的元素print(isinstance(dictionary["phone"], str))print(isinstance(dictionary["age"], int))print(isinstance(dictionary["name"], str))print(dictionary["age"])if "age" in dictionary: # 判断dictionary中, 是否存在指定的key print(dictionary["age"])for key in dictionary: print(key, '\t =&gt; \t', dictionary[key])print(dictionary.pop("age")) # 删除指定的keyprint(dictionary.get("Age")) # None# print(dictionary["Age"]) # KeyError: 'Age'print(dictionary.get("Age", -1)) # -1, 若Map中没对应的key, 则返回指定的默认值]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 环境的安装与HelloWord]]></title>
    <url>%2F2017%2F12%2F23%2Farticle%2Fpython%2Farticle-python_01%2F</url>
    <content type="text"><![CDATA[Python 环境的安装与HelloWord Python 作为一种解释型语言, 最近几年他的影响力渐渐扩大.说来可笑, 我说想学Python的原因, 是想用 Python 写一个爬虫程序, 去爬取网易云音乐中的MV. 一开始就在网上找一些爬虫的代码的示例, 发现完全不懂, 于是就想系统的学习一下这门语言. 之前也接触过其他的解释型语言(JavaScript), 我想应该不会过费力. 首先, 安装环境, 选择IDE 我安装的是 Python 3 IDE 我用的是 Sublime Text 3 配置 IDE (前提是python要加到环境变量中, 这在安装时, 就已经修改过了)123456789101112131415&#123; "shell_cmd": "python -u \"$file\"", "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.python", "env": &#123;"PYTHONIOENCODING": "utf-8"&#125;, "variants": [ &#123; "name": "Customize Python", "shell_cmd": "python \"$&#123;file&#125;\"", &#125; ]&#125; 编写 Hello World 在编写程序之前, 给Python一个独立的工作空间 创建 hello.py 在文件中, 直接写下面这一句, 就是可以执行了1print(&quot;Hello World!&quot;) 先体验一下Python的命令行:在hello.py文件所在的目录下, 调出命令行执行 python hello.py 执行结果: 也可以在 Sublime Text 3 中按 Ctrl + B 执行结果:]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie, Session, Token]]></title>
    <url>%2F2017%2F04%2F25%2Fnode%2Fnode-cookie-session-token%2F</url>
    <content type="text"><![CDATA[Cookie, Session, Token的区别与联系 Cookie, Session, Token 这三者都解决了HTTP协议无状态的问题 Cookie机制Cookie机制 是采用在客户端保持状态的方案. Cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的Cookie，如果某个Cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该Cookie附在请求资源的HTTP请求头上发送给服务器。 Cookie的内容主要包括：名字、值、过期时间、路径和域。路径与域一起构成Cookie的作用范围。 若不设置过期时间，则表示这个Cookie的生命期为浏览器会话期间，关闭浏览器窗口，Cookie就消失。这种生命期为浏览器会话期的Cookie被称为 会话Cookie. 会话Cookie一般不存储在硬盘上而是保存在内存里. 若设置了过期时间，浏览器就会把Cookie保存在硬盘上，关闭后再次打开浏览器，这些Cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里Cookie，不同的浏览器有不同的处理方式。 Session 机制Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个Session时，服务器首先检查这个客户端的请求里是否已包含了一个Session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session,服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以伪造的字符串，这个session id将被 在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器 可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字就是类似于SESSIONID。 由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 两种方式： 第一种：URL重写（常用），就是把session id直接附加在URL路径的后面。 第二种：表单隐藏字段（现已很少使用）。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。 Ps: GitHub 貌似没打算用这两种方式: “Cookies must be enabled to use GitHub.” Token机制Token的意思是“令牌”，是用户身份的验证方式，最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名)，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器。还可以把不变的参数也放进Token，避免多次查库 Cookie 与 Session 传统身份验证的方法HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 基于 Token 的身份验证方法 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 打破误解 只要关闭浏览器 ，session就消失了？ 不对。对Session来说，除非程序通知服务器删除一个 Session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除Session。 然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分Session机制都使用会话Cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的Session。如果服务器设置的Cookie被保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够打开原来的Session. 恰恰是由于关闭浏览器不会导致Session被删除，迫使服务器为Session设置了一个失效时间，当距离客户端上一次使用Session的时间超过这个失效时间时，服务器就可以以为客户端已经停止了活动，才会把Session删除以节省存储空间。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Oracle 的NULL]]></title>
    <url>%2F2016%2F12%2F30%2Fnode%2Fdatabase%2Fnode-oracle_04%2F</url>
    <content type="text"><![CDATA[关于Oracle 的NULL 原本设想 两数相加 123select a+b from ( select 11 A, 22 B from dual) 结果: 33 但是如果其中一个数为NULL时 123select a+b from ( select null A, 22 B from dual) 结果: null没有得到我们预期的结果: 22 正确的写法: 123select nvl(a,0)+nvl(b,0) from ( select null A, 22 B from dual) 结果: 22 NULL参加统计 123456789select count(A) from ( select 1 A from dual union select 2 A from dual union select 3 A from dual union select 4 A from dual) 结果: 4 如果统计的数据中有NULL值： 123456789select count(A) from ( select 1 A from dual union select 2 A from dual union select null A from dual union select 4 A from dual) 结果: 3 显然没有达到我们计数统计的需求应该写成这样: 123456789select count(decode(A, null, 1, 1)) from ( select 1 A from dual union select 2 A from dual union select null A from dual union select 4 A from dual) 结果: 4]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的 Oracle Function]]></title>
    <url>%2F2016%2F12%2F04%2Fnode%2Fdatabase%2Fnode-oracle_05%2F</url>
    <content type="text"><![CDATA[简单的 Oracle Function 1234567891011-- 简单的 Functioncreate or replace function get_sal(a in number, b in number) return number is result number; begin result := a + b; return(result); end;-- 调用 Functionselect get_sal(1,2) from dual;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环引用 to JSON]]></title>
    <url>%2F2016%2F09%2F24%2Fnode%2Fjava%2Fnode-j2se_02%2F</url>
    <content type="text"><![CDATA[循环引用 to JSON DisableCircularReferenceDetect来禁止循环引用检测： JSON.toJSONString(…, SerializerFeature.DisableCircularReferenceDetect) 当进行toJSONString的时候，默认如果重用对象的话，会使用引用的方式进行引用对象。 12345678910&#123; "颜色": [ &#123; "$ref": "$.itemSkuList[0].itemSpecificationList[0]" &#125;, &#123; "$ref": "$.itemSkuList[1].itemSpecificationList[0]" &#125; ]&#125; 循环引用很多场景中，我们需要序列化的对象中存在循环引用，在许多的json库中，这会导致stackoverflow。在功能强大的fastjson中，你不需要担心这个问题。例如: 123456A a = new A();B b = new B(a);a.setB(b);String text = JSON.toJSONString(a); //&#123;"b":&#123;"a":&#123;"$ref":".."&#125;&#125;&#125;A a1 = JSON.parseObject(text, A.class);Assert.assertTrue(a1 == a1.getB().getA()); 引用是通过”$ref”来表示的 引用 描述 “$ref”:”..” 上一级 “$ref”:”@” 当前对象，也就是自引用 “$ref”:” ¥” 根对象 “$ref”:” ¥.children.0” 基于路径的引用，相当于 root.getChildren().get(0)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBA 操作 Excel 数据筛查]]></title>
    <url>%2F2016%2F09%2F22%2Fnode%2Fnode-vba_1%2F</url>
    <content type="text"><![CDATA[VBA 操作 Excel 数据筛查 今天要统计程序中用到了哪些表, 统计出来, 发现有很多重复的就想到用Excel筛一下 1234567891011121314151617181920212223242526272829303132Sub cal()'' cal 宏' Dim num As Integer Dim dataCol As Integer Dim maxRow As Integer Dim resultCol As Integer num = 1 dataCol = 4 maxRow = 2728 resultCol = 6 For i = 1 To maxRow For j = i + 1 To maxRow If Cells(i, dataCol) = Cells(j, dataCol) And Not Cells(j, dataCol).Interior.Color = 65535 Then Cells(j, dataCol).Interior.Color = 65535 End If Next Next For i = 1 To maxRow If Not Cells(i, dataCol).Interior.Color = 65535 Then Cells(num, resultCol) = Cells(i, dataCol) num = num + 1 End If NextEnd Sub 自定义了一个宏, 处理这个问题]]></content>
      <categories>
        <category>VBA</category>
      </categories>
      <tags>
        <tag>VBA</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 临时表]]></title>
    <url>%2F2016%2F09%2F19%2Fnode%2Fdatabase%2Fnode-oracle_06%2F</url>
    <content type="text"><![CDATA[Oracle 临时表 Oracle 临时表临时表空间分配一块内存空间。也就是说只有向临时表中插入数据时，才会给临时表分配存储空间。临时表分事务级临时表和会话级临时表。事务级临时表只对当前事务有效，通过语句：ON COMMIT DELETE ROWS 语句指定。会话级临时表对当前会话有效，通过语句：ON COMMIT PRESERVE ROWS语句指定。 会话级: 只有该会话可以访问临时表中的内容, 其他Session 无法访问 Oracle 删除其他Session中的临时表因为表KOL_XX_FIN050_TEMP 为临时表，而且有其他session正在使用。 处理步骤： 先从 dba_objects / user_objects中查询到该表的object_id: select object_id from dba_objects where object_name=upper(‘KOL_XX_FIN050_TEMP’); 根据查到的object_id知道使用该表的session： select * from v$lock where id1=&amp;object_id; 在从v$session视图中查到该session的SID和SERIAL#： select * from v$session where sid=331; 杀掉这些进程: alter system kill session ‘SID,SERIAL#’;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 JavaScript 闭包]]></title>
    <url>%2F2016%2F09%2F19%2Fnode%2Fjavascript%2Fnode-javascript_01%2F</url>
    <content type="text"><![CDATA[初识 JavaScript 闭包 12345678910// 神奇的重名方法var sayHello = function() &#123; return 'Hello var';&#125;;function sayHello(name) &#123; return 'Hello function';&#125;;alert(sayHello()); JavaScript 会默认将 Function 提到最前面. 12345678910var global_var1 = 11;function global_function1(parameter_a)&#123; var local_var1 = 12 ; function local_function1(parameter_b)&#123; return parameter_b + local_var1 + parameter_a + global_var1; &#125; return local_function1 ;&#125;var global_sum = global_function1(13);alert(global_sum(14)); 返回 50. global_var1, global_sum 全局变量 var global_sum = global_function1(13); 执行global_function1方法时, 将local_function1函数返回给, global_sum global_sum(14); 因为 global_sum 是全局变量, 所以会一直保存 local_function1 函数在内存中. 又因为 local_function1 依赖于 global_function1 所以 global_function1 也会保存在内存]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 JavaScript 命名空间]]></title>
    <url>%2F2016%2F09%2F19%2Fnode%2Fjavascript%2Fnode-javascript_02%2F</url>
    <content type="text"><![CDATA[初识 JavaScript 命名空间 1234567891011121314151617181920// NameSpace By Functionvar NameSpace = window.NameSpace || &#123;&#125;;NameSpace.Hello = function() &#123; this.name = 'world';&#125;;NameSpace.Hello.prototype.sayHello = function(_name) &#123; return 'Hello ' + (_name || this.name);&#125;;var hello = new NameSpace.Hello();alert(hello.sayHello("JavaScript"));// NameSpace By Objectvar NameSpace = window.NameSpace || &#123;&#125;;NameSpace.Hello = &#123; name: 'World!!', sayHello: function(_name) &#123; return 'Hello ' + (_name || this.name); &#125;&#125;;alert(NameSpace.Hello.sayHello());]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 字段内容转行]]></title>
    <url>%2F2016%2F09%2F13%2Fnode%2Fdatabase%2Fnode-oracle_07%2F</url>
    <content type="text"><![CDATA[Oracle 字段内容转行 内容以 , 分割 , 多列展示 1234SELECT REGEXP_SUBSTR(BHALL, '[^, ]+', 1, ROWNUM) BH FROM (SELECT ('1A000000002702758284, 1A000000002702758285, 1A000000002702758334') BHALL FROM DUAL)CONNECT BY ROWNUM &lt;= LENGTH(BHALL) - LENGTH(REPLACE(BHALL, ',', '')) + 1]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义对象, 绑定get, set 方法]]></title>
    <url>%2F2016%2F09%2F11%2Fnode%2Fjavascript%2Fnode-javascript_03%2F</url>
    <content type="text"><![CDATA[自定义对象, 绑定get, set 方法 自定义对象, 通过 defineSetter 与 defineGetter 绑定get, set 方法 12345678910111213141516var c = &#123;sum:"", show:function(num, num1) &#123; sum = num + num1;&#125;&#125;;c.__defineSetter__('scum', function(y) &#123; this.sum = sum + "..." + y;&#125;);c.__defineGetter__('scum', function() &#123; return "sum = " + sum;&#125;);c.show(1,3);c.scum = "1";alert(c.sum);alert(c.scum);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 格式化时间类型]]></title>
    <url>%2F2016%2F09%2F11%2Fnode%2Fjavascript%2Fnode-javascript_04%2F</url>
    <content type="text"><![CDATA[JavaScript 格式化时间类型 12345678910111213141516171819202122232425262728293031Date.prototype.__defineGetter__('year', function() &#123;return this.getFullYear();&#125;);Date.prototype.__defineSetter__('year', function(y) &#123;this.setFullYear(y)&#125;);Date.prototype.__defineGetter__('month', function() &#123;return this.getMonth();&#125;);Date.prototype.__defineSetter__('month', function(m) &#123;this.setMonth(m)&#125;);Date.prototype.format = function(fmt) &#123; //author: meizz var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); for(var k in o) if(new RegExp("("+ k +")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); return fmt; &#125;var now = new Date;now.year = 2007;now.month = 10;alert(now.year);alert(now.month);alert(now.format("yyyy-MM-dd HH:mm:ss"));alert(now.format("yyyy-MM-dd"));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 定义对象的两种方式]]></title>
    <url>%2F2016%2F09%2F11%2Fnode%2Fjavascript%2Fnode-javascript_05%2F</url>
    <content type="text"><![CDATA[JavaScript 定义对象的两种方式 方法一: 12345678var Cat = function() &#123; var sum = "" this.show = function(num, num1) &#123; sum = num + num1; alert("sum = " + sum); &#125;&#125;var c = new Cat(); 方法二: 123var c = &#123;sum:"", show:function(num, num1) &#123;sum = num + num1; alert("sum = " + sum);&#125;&#125;;c.show(1,1);alert(t);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 定义对象的两种方式]]></title>
    <url>%2F2016%2F09%2F11%2Fnode%2Fjavascript%2Fnode-javascript_16%2F</url>
    <content type="text"><![CDATA[方法一: 12345678var Cat = function() &#123; var sum = "" this.show = function(num, num1) &#123; sum = num + num1; alert("sum = " + sum); &#125;&#125;var c = new Cat(); 方法二: 123var c = &#123;sum:"", show:function(num, num1) &#123;sum = num + num1; alert("sum = " + sum);&#125;&#125;;c.show(1,1);alert(t);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句 查看Oracle版本]]></title>
    <url>%2F2016%2F09%2F09%2Fnode%2Fdatabase%2Fnode-oracle_08%2F</url>
    <content type="text"><![CDATA[SQL语句 查看Oracle版本 方法一：v$version 1select * from v$version; 方法二：product_component_version 1select * from product_component_version; 方法三：dbms_output.put_line( dbms_db_version.version ) 12SET SERVEROUTPUT ON EXEC dbms_output.put_line( dbms_db_version.version );]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 不使用 $]]></title>
    <url>%2F2016%2F09%2F05%2Fnode%2Fjavascript%2Fnode-javascript_06%2F</url>
    <content type="text"><![CDATA[jQuery 不使用 $ 交出 $ 的控制权 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"/&gt; &lt;script src="js/jquery.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; jQuery.noConflict();// 交出 $ 的控制权 jQuery(document).ready(function() &#123; alert("aaaaaaaaaaaaa") &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初认 Oracle 存储过程]]></title>
    <url>%2F2016%2F08%2F02%2Fnode%2Fdatabase%2Fnode-oracle_09%2F</url>
    <content type="text"><![CDATA[初认 Oracle 存储过程 存储过程 – 基础语法创建存储过程123456789CREATE OR REPLACE PROCEDURE 存储过程名字 ( 参数1 [&lt;in, out, in out&gt;] 数据类型, 参数2 [&lt;in, out, in out&gt;] 数据类型 ) IS变量1 INTEGER :=0;变量2 DATE;BEGINEND; 变量赋值12SELECT 列.... INTO 变量... FROM 表名 WHERE 条件....;变量1 := 值; 分支123IF V_TEST=1 THEN do somethingEND IF; 循环123WHILE V_TEST=1 LOOP do somethingEND LOOP; 游标1234567-- 定义游标 CURSOR 游标名 IS SELECT 列名.... FROM 表名... WHERE 条件....;-- FOR ... IN 使用 游标 FOR 临时变量名 IN 游标名 LOOP do something END LOOP; 存储过程 – PL/SQL 工具调试 在 对象 窗口中 右击存储过程 添加调试信息 重新编译 测试]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Procedure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次 WebService 的调错经历]]></title>
    <url>%2F2016%2F07%2F20%2Fnode%2Fjava%2Fnode-j2ee_03%2F</url>
    <content type="text"><![CDATA[Ajax调用, 并解析返回的数据 1234567891011javax.xml.ws.WebServiceException is not a valid service. Valid services are:javax.xml.ws.WebServiceException: &#123;&#125;InterServiceImpService is not a valid service. Valid services are: &#123;&#125;InterServiceService at com.sun.xml.ws.client.WSServiceDelegate.&lt;init&gt;(WSServiceDelegate.java:249) at com.sun.xml.ws.client.WSServiceDelegate.&lt;init&gt;(WSServiceDelegate.java:197) at com.sun.xml.ws.client.WSServiceDelegate.&lt;init&gt;(WSServiceDelegate.java:187) at weblogic.wsee.jaxws.spi.WLSServiceDelegate.&lt;init&gt;(WLSServiceDelegate.java:84) at weblogic.wsee.jaxws.spi.WLSProvider$ServiceDelegate.&lt;init&gt;(WLSProvider.java:598) at weblogic.wsee.jaxws.spi.WLSProvider.createServiceDelegate(WLSProvider.java:120) at weblogic.wsee.jaxws.spi.WLSProvider.createServiceDelegate(WLSProvider.java:112) at weblogic.wsee.jaxws.spi.WLSProvider.createServiceDelegate(WLSProvider.java:83) at javax.xml.ws.Service.&lt;init&gt;(Service.java:56) 今天我在调用使用cxf的webservice的时候出现这个异常。 这里的意思是：InterServiceImpService 不是可用的服务，正常可用的服务应该是InterServiceService。 不知道什么问题。后来发现我在webservice的服务方发布是的InterService，所以在wsdl文件中的server就是InterServiceService，但是呢，在客户端使用的是InterServiceImp实现类。这里匹配不上。 我将客户端的调用类InterServiceImp改为InterService或是将服务端的发布方法InterService改为InterServiceImp。就可以了。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 禁止Backspace 键]]></title>
    <url>%2F2016%2F06%2F13%2Fnode%2Fjavascript%2Fnode-javascript_07%2F</url>
    <content type="text"><![CDATA[JavaScript 禁止Backspace 键 123456789101112131415161718192021&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;禁止后退键&lt;/title&gt; &lt;script type="text/javascript"&gt; function keyDown() &#123; // 禁止使用backspace键 if(window.event.keyCode == 8) &#123; alert("不能使用backspace键"); event.returnValue=false; &#125; // 后面还可以禁止其它键，照着上面的方法写就行了 // 比如：if(event.shiftKey&amp;&amp;event.keyCode == 121) // 屏蔽shift+F10 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onkeydown="keyDown()" oncontextmenu="event.returnValue=false"&gt; 请按退格键测试 &lt;br&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义JSTL标签]]></title>
    <url>%2F2016%2F05%2F25%2Fnode%2Fjava%2Fnode-j2ee_01%2F</url>
    <content type="text"><![CDATA[JavaWeb项目中, 自定义JSTL标签 有WEB-INF下建立一个datetag.tld12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;1.2&lt;/jsp-version&gt; &lt;tag&gt; &lt;name&gt;date&lt;/name&gt; &lt;tag-class&gt;com.hoolai.pirates.football.util.DateTag&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;value&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 新建一个类DateTag123456789101112131415161718192021222324252627282930313233package pro.yuchen.demo.util; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Calendar; import javax.servlet.jsp.JspException; import javax.servlet.jsp.tagext.TagSupport; public class DateTag extends TagSupport &#123; private static final long serialVersionUID = -2312310581852395045L; private String value; @Override public int doStartTag() throws JspException &#123; String vv = "" + value; long time = Long.valueOf(vv); Calendar c = Calendar.getInstance(); c.setTimeInMillis(time); SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String s = dateformat.format(c.getTime()); try &#123; pageContext.getOut().write(s); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doStartTag(); &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 在jsp中引入1&lt;%@ taglib prefix="lzq" uri="/WEB-INF/lib/tld/datetag.tld"%&gt; 页面中用到的地方123456&lt;td align=&quot;left&quot;&gt; &lt;input name=&quot;endTime&quot; type=&quot;text&quot; value=&quot;&lt;lzq:date value=&quot;$&#123;res.endTime&#125;&quot;/&gt;&quot; class=&quot;input_bg&quot; /&gt;&lt;/td&gt; 这样在servlet里传过来的是long，在页面上用jstl可以格式化为 2014-05-04 18:18:22]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 查看表对应注释]]></title>
    <url>%2F2016%2F04%2F19%2Fnode%2Fdatabase%2Fnode-oracle_11%2F</url>
    <content type="text"><![CDATA[Oracle 查看表对应注释 12345-- 表注释select * from user_tab_comments;-- 字段注释select * from user_col_comments;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Dialog]]></title>
    <url>%2F2016%2F04%2F01%2Fnode%2Fjavascript%2Fnode-javascript_08%2F</url>
    <content type="text"><![CDATA[自定义 Dialog Dialog HTML Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;Dialog Demo&lt;/title&gt; &lt;script src=&quot;js/jquery.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/dialog.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/bootstrap.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/bootstrap.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/bootstrap-responsive.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/dialog.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 创建对话框 var dialog = new Dialog(); dialog.createDialog(); // 设置对话框标题 dialog.setTitle(&quot;提示&quot;); // 设置对话框消息 dialog.setMessage(&quot;是否删除该图片?&quot;); // 创建需要显示的按钮 var list = new Array(); var save = document.createElement(&quot;input&quot;); save.type = &quot;button&quot;; save.setAttribute(&quot;class&quot;,&quot;btn&quot;); save.value = &quot; 保 存 &quot;; save.onclick = function() &#123; dialog.hideDialog(); &#125; list[list.length] = save; // 设置对话框按钮 dialog.setButtons(list); // 显示对话框 dialog.showDialog(); &lt;/script&gt;&lt;/html&gt; Dialog JavaScript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function Dialog() &#123; /** * 创建对话框 * */ this.createDialog = function() &#123; var mask = document.getElementById(&quot;mask&quot;); var dialog = document.createElement(&quot;div&quot;); var title = document.createElement(&quot;div&quot;); var body = document.createElement(&quot;div&quot;); var foot = document.createElement(&quot;div&quot;); dialog.id = &quot;dialog&quot;; title.id = &quot;dialog-title&quot;; body.id = &quot;dialog-body&quot;; foot.id = &quot;dialog-foot&quot;; dialog.appendChild(title); dialog.appendChild(body); dialog.appendChild(foot); mask.appendChild(dialog); &#125; /** * 显示对话框 */ this.showDialog = function() &#123; $(&apos;#mask&apos;).fadeIn(&quot;fast&quot;, function()&#123; $(&apos;#dialog&apos;).slideDown(&quot;fast&quot;); &#125;); &#125; /** * 隐藏对话框 */ this.hideDialog = function() &#123; $(&apos;#dialog&apos;).slideUp(&quot;fast&quot;,function()&#123; $(&apos;#mask&apos;).fadeOut(&quot;fast&quot;); &#125;); &#125; /** * 设置标题显示内容 */ this.setTitle = function(title) &#123; $(&apos;#dialog-title&apos;).html(title); &#125; /** * 设置消息显示内容 */ this.setMessage = function(message) &#123; $(&apos;#dialog-body&apos;).html(message); &#125; /** * 添加按钮 * 默认会有一个关闭按钮 * * @param &#123;Object&#125; objs */ this.setButtons = function(objs) &#123; var button = document.createElement(&quot;input&quot;); button.type = &quot;button&quot;; button.setAttribute(&quot;class&quot;,&quot;btn&quot;); button.value = &quot; 确 认 &quot;; button.onclick = function() &#123; $(&apos;#dialog&apos;).slideUp(&quot;fast&quot;,function()&#123; $(&apos;#mask&apos;).fadeOut(&quot;fast&quot;); &#125;); &#125; if(undefined!=objs &amp;&amp; null!=objs &amp;&amp; objs.length&gt;0) &#123; for (var i=0; i&lt;objs.length; i++) &#123; $(&apos;#dialog-foot&apos;).append(objs[i]); &#125; button.value = &quot; 关 闭 &quot;; &#125; $(&apos;#dialog-foot&apos;).append(button); &#125;&#125; Dialog CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869*&#123; margin: 0px; padding: 0px;&#125;#mask &#123; display: none; position: absolute; top: 0%; left: 0%; width: 100%; height: 100%; background-color: black; z-index: 9997; -moz-opacity: 0.7; opacity: .70; filter: alpha(opacity=70);&#125;#dialog &#123; display: none; position: relative; top: 23px; width: 53%; min-height: 150px; border: 3px solid #CCCCCC; background-color: white; z-index: 9998; overflow: auto; /* 水平居中 */ margin-left: auto; margin-right: auto; /*修改对话框的字体*/ font-family: &quot;微软雅黑&quot;;&#125;#dialog-title &#123; position: absolute; height: 35px; width: 100%; top: 0px; left: 0px; font-size: 30px; font-weight: normal; background-color: #CCCCCC; padding-top: 7px;&#125;#dialog-foot &#123; background-color: #CCCCCC; position: absolute; height: 32px; width: 100%; bottom: 0px; right: 0px; padding-top: 3px; text-align: right;&#125;#dialog-body &#123; font-size: 15px; padding-top: 60px; padding-left: 23px; padding-bottom: 30px;&#125;#dialog-foot .btn &#123; margin-right: 10px;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 内使用 JavaScript]]></title>
    <url>%2F2016%2F03%2F08%2Fnode%2Fjavascript%2Fnode-javascript_09%2F</url>
    <content type="text"><![CDATA[CSS 内使用 JavaScript 12_position:absolute; _top:expression(eval(document.documentElement.scrollTop)); 这一段是CSS（层叠样式表）的代码，常用于网页的样式设计中 _position:absolute; 这句代码的意思是“位置：绝对定位”，也就是说元素的位置是相对于整个浏览器窗口的，而不是相对于父元素。一般要配合top、left属性使用。 _top:expression(eval(document.documentElement.scrollTop));top属性是定义元素的顶部在网页中的位置，而CSS中的expression属性是用来调用Javascript代码。所以expression后面的括号中就是一行Javascript代码。eval(document.documentElement.scrollTop); 其中，document.documentElement.scrollTop 的意思是获取当前页面滚动条所滚动到的位置的数值，而再用eval()函数把它计算成数值。 所以这句代码最终的意思就是：你浏览器窗口的滚动条滑到哪，这个元素的位置就在哪。 前面的下划线是CSS Hack中的用法，用来区分不同的浏览器以解决兼容问题，此处的下划线只有IE6能识别，而IE7、IE8、Firefox等浏览器是识别不了的，所以这两行代码只对IE6有效，其他浏览器是忽略它们的。要了解更多关于CSS Hack的信息]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Div嵌套 内层取消外层事件]]></title>
    <url>%2F2016%2F03%2F08%2Fnode%2Fjavascript%2Fnode-javascript_11%2F</url>
    <content type="text"><![CDATA[Div嵌套 内层取消外层事件 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Test Demo....&lt;/title&gt; &lt;style type="text/css"&gt; div[id=inner_1]:hover&#123; background-color: #AAAAAA; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="__temp"&gt; Outer &lt;div id="inner_1"&gt;Inner_1&lt;/div&gt; &lt;div id="inner_2"&gt;Inner_2&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; document.getElementById("__temp").onclick = function() &#123; alert("Outer......"); &#125; document.getElementById("inner_1").onclick = function() &#123; alert("Inner......"); event.cancelBubble=true; &#125; document.getElementById("inner_2").onclick = function() &#123; alert("Inner......");// event.cancelBubble=true; &#125; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 data-* 自定义属性]]></title>
    <url>%2F2016%2F03%2F07%2Fnode%2Fnode-html_1%2F</url>
    <content type="text"><![CDATA[HTML5 data-* 自定义属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Test Demo....&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt; &lt;span class="right" data-id = "0001" data-title = "标题0001" data-description = "描述0001" data-role = "1"&gt; Test1 &lt;/span&gt; &lt;span class="right" data-id = "0002" data-title = "标题0002" data-description = "描述0002" data-role = "2"&gt; Test2 &lt;/span&gt; &lt;/div&gt; &lt;div id="result"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var arr = document.getElementsByClassName("right"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = function() &#123; var rt = '&lt;br /&gt;'; var id = this.dataset.id; var title = this.dataset.title; var description = this.dataset.description; var role = this.dataset.role; document.getElementById("result").innerHTML = "ID: " + id + rt + "Title: " + title + rt + "Description: " + description + rt + "Role: " + role; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 在标签中写入 自定义属性用dataset 获取自定义属性集合]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 字段 增删改]]></title>
    <url>%2F2016%2F03%2F04%2Fnode%2Fdatabase%2Fnode-oracle_03%2F</url>
    <content type="text"><![CDATA[Oracle 字段 增删改 123456--JKJYFJB-- Add/modify columns ALTER TABLE JKJYFJB ADD FJLX VARCHAR2(10);-- Add comments to the columns COMMENT ON COLUMN JKJYFJB.FJLX IS '附件类型'; 添加字段的语法： 1alter table tablename add (column datatype [default value][null/not null],….); 修改字段的语法： 1alter table tablename modify (column datatype [default value][null/not null],….); 删除字段的语法： 1alter table tablename drop (column);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 查询结果列转行]]></title>
    <url>%2F2016%2F02%2F27%2Fnode%2Fdatabase%2Fnode-oracle_10%2F</url>
    <content type="text"><![CDATA[Oracle 查询结果列转行 查询结果列转行 wm_concat() 1select wm_concat(MC) from ZDJSJYRYLB where instr('01,02,03', DM) &gt; 0]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 树]]></title>
    <url>%2F2016%2F01%2F31%2Fnode%2Fjavascript%2Fnode-javascript_10%2F</url>
    <content type="text"><![CDATA[JavaScript 树 Tree HTML Demo 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/tree.css"/&gt; &lt;script src="js/jquery-2.1.3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/tree.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="left"&gt; &lt;div id="tree_container"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="right"&gt; &lt;div id="tree_container_right"&gt;aaaaaaaaaaaaaaa&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; // 创建对象 var tree = new Tree(); // 初始化数据 tree.initData('&#123;"id" :"130100", "parent":"#", "text" :"石家庄", "child" : [&#123;"id" :"130101", "parent":"130100", "text" :"桥东区", "child" : [&#123;"id" :"130101001", "parent":"130101", "text" :"胜南街道社区卫生服务中心", "child" : "#"&#125;, &#123;"id" :"130101002", "parent":"130101", "text" :"胜北街道社区卫生服务中心", "child" : "#"&#125;, &#123;"id" :"130101003", "parent":"130101", "text" :"中山东路街道社区卫生服务中心", "child" : "#"&#125; ] &#125;, &#123;"id" :"130102", "parent":"130100", "text" :"桥西区", "child" : [&#123;"id" :"130102001", "parent":"130102", "text" :"红旗街道社区卫生服务中心", "child" : "#"&#125;, &#123;"id" :"130102002", "parent":"130102", "text" :"新石街道社区卫生服务中心", "child" : "#"&#125;, &#123;"id" :"130102003", "parent":"130102", "text" :"友谊街道道社区卫生服务中心", "child" : "#"&#125; ] &#125; ] &#125;'); // 初始化树 tree.init("tree_container"); &lt;/script&gt;&lt;/html&gt; JavaScript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function Tree() &#123; this.treeContainer = &#123;&#125;; this.root = &#123;&#125;; this.data = &#123;&#125;; /** * 创建节点 * * @param &#123;Object&#125; container 容器 * @param &#123;String&#125; type 节点类型 * @param &#123;String&#125; nodeId 节点id * @param &#123;String&#125; text 节点文本 */ this.createNode = function (container, type, nodeId, text) &#123; var node = document.createElement(type); node.id = nodeId; node.innerText = text; container.appendChild(node); return node; &#125; /** * 初始化数据 * @param &#123;JSON&#125; data JSON数据 */ this.initData = function(data) &#123; this.data = eval("([" + data + "])"); &#125; /** * 初始化组件 * @param &#123;String&#125; containerId 容器id */ this.init = function(containerId) &#123; this.treeContainer = document.getElementById(containerId); this.root = this.createNode(this.treeContainer,"ul","root", ""); this.createTree(this.root, this.data); &#125; /** * 节点单击事件 */ this.click = function() &#123; try&#123; var display = document.getElementById("_"+this.id).style.display; if("" == display)&#123; document.getElementById("_"+this.id).style.display = "none"; &#125; else &#123; document.getElementById("_"+this.id).style.display = ""; &#125; &#125;catch(e) &#123;&#125; &#125; /** * 创建树 * @param &#123;Object&#125; container 容器 * @param &#123;Object&#125; datas 数据源 */ this.createTree = function(container,datas) &#123; for (var i = 0; i &lt; datas.length; ++i) &#123; var data = datas[i]; var branches = this.createNode(container,"li", data.id, data.text); branches.onclick = this.click; if("#" != data.child)&#123; var twig = this.createNode(container,"ul", "_"+data.id, ""); this.createTree(twig, data.child); &#125; &#125; &#125;&#125; CSS 1234567891011121314li &#123; list-style-type: none; cursor: pointer; font-family: "微软雅黑"; padding-left: 5px;&#125;li:hover &#123; background-color: #ccc;&#125;ul &#123; padding-left: 17px;&#125; JSON 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[ &#123; "id": "130100", "parent": "#", "text": "石家庄", "child": [ &#123; "id": "130101", "parent": "130100", "text": "桥东区", "child": [ &#123; "id": "130101001", "parent": "130101", "text": "胜南街道社区卫生服务中心", "child": "#" &#125;, &#123; "id": "130101002", "parent": "130101", "text": "胜北街道社区卫生服务中心", "child": "#" &#125;, &#123; "id": "130101003", "parent": "130101", "text": "中山东路街道社区卫生服务中心", "child": "#" &#125; ] &#125;, &#123; "id": "130102", "parent": "130100", "text": "桥西区", "child": [ &#123; "id": "130102001", "parent": "130102", "text": "红旗街道社区卫生服务中心", "child": "#" &#125;, &#123; "id": "130102002", "parent": "130102", "text": "新石街道社区卫生服务中心", "child": "#" &#125;, &#123; "id": "130102003", "parent": "130102", "text": "友谊街道道社区卫生服务中心", "child": "#" &#125; ] &#125; ] &#125;]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下拉列表 读写操作]]></title>
    <url>%2F2016%2F01%2F27%2Fnode%2Fjavascript%2Fnode-javascript_12%2F</url>
    <content type="text"><![CDATA[下拉列表 读写操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span id="picking"&gt; City: &lt;select name="city" id="city"&gt; &lt;option value="130100"&gt;石家庄&lt;/option&gt; &lt;option value="130300"&gt;保定&lt;/option&gt; &lt;option value="130500"&gt;张家口&lt;/option&gt; &lt;/select&gt; &lt;span id="add" style="display: none;"&gt; &lt;input type="text" id="addCity" /&gt; 格式: 130100,石家庄 &lt;/span&gt; &lt;/span&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; document.getElementById("picking").ondblclick = function()&#123; document.getElementById("city").style.display = "none"; document.getElementById("add").style.display = "inline"; &#125; document.getElementById("addCity").onkeyup = function(e)&#123; if(e.keyCode == 13) &#123; var city = document.getElementById("city"); var arr = this.value.split(",") try&#123; var content = eval('(&#123;"dm":"' + arr[0] + '", "mc":"' + arr[1] + '"&#125;)'); if(content.mc === "undefined") &#123; throw("格式不正确!"); &#125; city.innerHTML += '&lt;option value="' + content.dm + '"&gt;' + content.mc + '&lt;/option&gt;'; &#125;catch(e)&#123; alert(e); &#125; document.getElementById("city").style.display = "inline"; document.getElementById("add").style.display = "none"; document.getElementById("addCity").value = ""; &#125; &#125; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 关于Select和CheckBox的一些操作]]></title>
    <url>%2F2016%2F01%2F27%2Fnode%2Fjavascript%2Fnode-javascript_13%2F</url>
    <content type="text"><![CDATA[JavaScript 关于Select和CheckBox的一些操作 1234567891011121314151617181920212223242526272829303132333435363738/** * 判断复选框是否为空 * 需要传入 checkBox的name属性 * 返回true,为空 * 返回false, 不为空 */function checkBoxOrRadioIsNull(name) &#123; var arr = document.getElementsByName(name); var i; for (i = 0; i &lt; arr.length; i++) &#123; if(arr[i].checked) &#123; break; &#125; &#125; if(i &lt; arr.length) &#123; return false; &#125; else &#123; return true; &#125;&#125;/** * 选择下拉框的公用方法 * 需要传入 select的id属性 和 需要选中的值 * */function selectPicking(id, val) &#123; var arr = document.getElementById(id).options; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i].value == val) &#123; document.getElementById(id).selectedIndex = i; break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe 的js变量值]]></title>
    <url>%2F2015%2F12%2F02%2Fnode%2Fjavascript%2Fnode-javascript_14%2F</url>
    <content type="text"><![CDATA[父页面获取iframe 子页面的js变量值, 以及子页面获取父页面js变量 父页面获取iframe 子页面的js变量值方法只有一种： 步骤： 1、获取iframe节点 2、获取iframe中的变量 示例 a.html&lt;iframe id=&#39;x&#39; name=&#39;x&#39; src=&#39;b.html&#39;/&gt; b.html 123&lt;script&gt; var y=&apos;1&apos;;&lt;/script&gt; 在a.html中获取y，则可以通过以下方式document.frames[&#39;x&#39;].y //先获取frame,在获取y 子页面获取父页面js变量父页面 &lt;input type=&quot;hidden&quot; id=&quot;result&quot; name=&quot;result&quot; value=&quot;&quot; /&gt; 子页面 &lt;input type=&quot;hidden&quot; id=&quot;_bh${da.bh}&quot; value=&#39;${da.bh},${da.name},${da.sfzh},${da.lxdh}&#39;/&gt; 在子页面取得父页面的对象，并赋值 123456function setVal(obj) &#123; var id = "_"+obj.id; var val = document.getElementById(id).value; var parent = window.parent.form1.result; parent.value=val;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 替换字段中的内容]]></title>
    <url>%2F2015%2F11%2F10%2Fnode%2Fdatabase%2Fnode-oracle_01%2F</url>
    <content type="text"><![CDATA[Oracle 替换字段中的内容 12update statsfielddefine t set t.showname = REPLACE(t.showname ,substr(t.showname ,7,2) ,'随访') where t.showname like '重性精神疾病访视%' commit; substr(字符串,截取开始位置,截取长度) //返回截取的字 substr(‘Hello World’,0,1) //返回结果为 ‘H’ *从字符串第一个字符开始截取长度为1的字符串 substr(‘Hello World’,1,1) //返回结果为 ‘H’ *0和1都是表示截取的开始位置为第一个字符 substr(‘Hello World’,2,4) //返回结果为 ‘ello’ substr(‘Hello World’,-3,3)//返回结果为 ‘rld’ *负数(-i)表示截取的开始位置为字符串右端向左数第i个字符 replace 函数用法如下： replace（’将要更改的字符串’,’被替换掉的字符串’,’替换字符串’）]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 创建序列]]></title>
    <url>%2F2015%2F11%2F10%2Fnode%2Fdatabase%2Fnode-oracle_02%2F</url>
    <content type="text"><![CDATA[Oracle 创建序列 1234567CREATE SEQUENCE SEQ_FJHHZDJB --序列名 INCREMENT BY 1 -- 每次加几个 START WITH 1 -- 从1开始计数 NOMAXVALUE -- 不设置最大值 NOCYCLE -- 一直累加，不循环 CACHE 20 NOORDER;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle &符号如何插入（转义）]]></title>
    <url>%2F2015%2F11%2F03%2Fnode%2Fdatabase%2Fnode-oracle_12%2F</url>
    <content type="text"><![CDATA[Oracle &amp;符号如何插入（转义） 123insert into table values( 'http://localhost:8080/index.action?username=138&amp;type=1 ');insert into table values( 'http://localhost:8080/index.action?username=138 '||chr(38)|| 'type=1 ');]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 JDBC 自动提交]]></title>
    <url>%2F2015%2F10%2F13%2Fnode%2Fjava%2Fnode-jdbc_01%2F</url>
    <content type="text"><![CDATA[关于 JDBC 自动提交 设置 JDBC 连接对象关闭 自动提交 conn.setAutoCommit(false); 在执行完SQL后, 要提交一下, conn.commit(); 记得这个连接对象, 一定要是公共的一个连接对象, 关闭自动提交, 一定是要在初始化连接对象时设置的. conn.rollback(); 是在SQL语句执行错误时，做数据回滚用的 在执行完你的逻辑算法后, 提交一下 在一个处理逻辑中，打开一个数据库连接，处理结束时，关闭这个连接 conn.setAutoCommit(true); 是控制是否每条SQL执行完后自动提交]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 对称加密算法(DES)]]></title>
    <url>%2F2015%2F10%2F13%2Fnode%2Fjava%2Fnode-j2se_01%2F</url>
    <content type="text"><![CDATA[Java 中的对称加密算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.yuchen352416.example;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.Key;import java.security.NoSuchAlgorithmException;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.security.auth.kerberos.KerberosKey;import javax.security.auth.kerberos.KerberosPrincipal;import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;public class EncryptData &#123; // 用于产生指定key的常量定义---开始 private static String PRINCIPAL_NAME = "yuchen352416@163.com";// 产生key的主体名称 private static String KEY_PASSWORD = "yuchen352416@163.com";// key的密码 private static final String ALGORITHM_NAME = "DES";// 算法名称 // 用于产生指定的key的常量定义---结束 // 字符串转16 public static String toHexString(String s) &#123; String str = ""; for (int i = 0; i &lt; s.length(); i++) &#123; int ch = (int) s.charAt(i); String s4 = Integer.toHexString(ch); str = str + s4; &#125; return str; &#125; // 16转字符串 public static String toStringHex(String s) &#123; byte[] baKeyword = new byte[s.length() / 2]; for (int i = 0; i &lt; baKeyword.length; i++) &#123; try &#123; baKeyword[i] = (byte) (0xff &amp; Integer.parseInt( s.substring(i * 2, i * 2 + 2), 16)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; try &#123; s = new String(baKeyword, "utf-8");// UTF-16le:Not &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; return s; &#125; /** * DES加密字符串，返回加密后的字符串 * * @param encryptString * 要加密的字符串 * @param strings * 不传此参数按默认生成密钥 参数数组，[0]=加密主体名称，[1]=key的密码 * @return 返回base64转码后的字符串 * @throws InvalidKeyException * @throws NoSuchAlgorithmException * @throws NoSuchPaddingException * @throws UnsupportedEncodingException * @throws IllegalBlockSizeException * @throws BadPaddingException */ public static String encrypt(String encryptString, String... strings) &#123; try &#123; Key key = createKey(strings); Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); byte[] by = encryptString.getBytes("utf8"); cipher.init(Cipher.ENCRYPT_MODE, key);// 使用私鈅加密 byte[] cipherText = cipher.doFinal(by); return Base64.encode(cipherText).replaceAll("\n", ""); &#125; catch (Exception e) &#123; //Log.error(e); return encryptString; &#125; &#125; /** * DES解密字符串 * * @param decryptString要解密的字符串 * @param strings生成密鑰的參數 * 不传此参数按默认生成密钥 参数数组，[0]=加密主体名称，[1]=key的密码 * @return * @throws NoSuchAlgorithmException * @throws NoSuchPaddingException * @throws UnsupportedEncodingException * @throws InvalidKeyException * @throws IllegalBlockSizeException * @throws BadPaddingException */ public static String decrypt(String decryptString, String... strings) &#123; try &#123; Key key = createKey(strings); Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); byte[] by = Base64.decode(decryptString); cipher.init(Cipher.DECRYPT_MODE, key);// 使用私鈅加密 byte[] cipherText = cipher.doFinal(by); return new String(cipherText, "utf-8"); &#125; catch (Exception e) &#123; return decryptString; &#125; &#125; /** * 创建指定的key，参数数组含义： strings[0]=生成key的主体名称 * strings[1]=key的密码（参考命名格式xxx@xx.xxx其他命名格式参考Java Cryptography Architecture * API Specification &amp; Reference 中的附录 A） strings[2]=算法名称如果不传参数按默认值 * * @param strings * @return */ public static Key createKey(String... strings) &#123; String algorithm = ALGORITHM_NAME; String name = PRINCIPAL_NAME; String password = KEY_PASSWORD; switch (strings.length) &#123; case 1: name = strings[0]; break; case 2: name = strings[0]; password = strings[1]; break; case 3: name = strings[0]; password = strings[1]; algorithm = strings[2]; break; &#125; KerberosPrincipal kerberosPrincipal = new KerberosPrincipal(name); Key key = new KerberosKey(kerberosPrincipal, password.toCharArray(), algorithm); return key; &#125; /** * 产生一个随机key，并保存到文件中 * * @param file */ public static void setPriveKey(String file) &#123; FileOutputStream fos; try &#123; fos = new FileOutputStream(file); KeyGenerator keyGen = KeyGenerator.getInstance("DES"); keyGen.init(56); Key key = keyGen.generateKey();// 生成私钥Key ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(key); oos.close(); &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; /** * 从文件中获取key * * @param file * @return * @throws Exception */ @SuppressWarnings("resource") public static Key getPriveKey(String file) throws Exception &#123; FileInputStream fis = new FileInputStream(file); ObjectInputStream ois = new ObjectInputStream(fis); Key key = (Key) ois.readObject(); return key; &#125;&#125; 使用加密类 1234567891011121314151617181920package com.yuchen352416.example;public class Test &#123; public static void main(String args[]) &#123; try &#123; // 需要加密的字符串 String str = "yuchen352416"; // 加密后的字符串 String eStr = EncryptData.encrypt(str); // 解密已经加密的字符串 String dStr = EncryptData.decrypt(eStr); System.out.println(eStr); System.out.println(dStr); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Oracle 描述乱码问题]]></title>
    <url>%2F2015%2F09%2F11%2Fnode%2Fdatabase%2Fnode-oracle_13%2F</url>
    <content type="text"><![CDATA[解决 Oracle 描述乱码问题 在系统变量中新建系统变量变量名： NLS_LANG变量值： AMERICAN_AMERICA.ZHS16GBK 注意： 变量值 是要和服务器上使用的字符集要一致， 我这里服务器上使用的是 AMERICAN_AMERICA.ZHS16GBK]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 重定向 携带参数]]></title>
    <url>%2F2015%2F08%2F30%2Fnode%2Fjava%2Fnode-j2ee_04%2F</url>
    <content type="text"><![CDATA[SpringMVC 重定向 携带参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yuchen.picture.web;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import com.yuchen.picture.dao.UserDAO;import com.yuchen.picture.entity.User;@Controller@Transactionalpublic class SignInController &#123; @Autowired private UserDAO userDAO; @RequestMapping(value="/user/sign_in_ing.htm") public String sign_in(User user, String remember, RedirectAttributes attributes, HttpServletRequest request, HttpServletResponse response) &#123; User u = userDAO.findByName(user.getName()); if(null != user &amp;&amp; null != u &amp;&amp; user.getPassword().equals(u.getPassword())) &#123; // 登录成功, 将用户信息存到Session中 request.getSession().setAttribute("loginUser", u); // 将用户信息存到cookie中 if("1".equals(remember)) &#123; Cookie usernameCookie = new Cookie("username", u.getName()); Cookie passwordCookie = new Cookie("password", u.getPassword()); usernameCookie.setMaxAge(7*24*60*60); passwordCookie.setMaxAge(7*24*60*60); response.addCookie(usernameCookie); response.addCookie(passwordCookie); &#125; // 执行跳转 return "redirect:/index.htm"; &#125; else &#123; // 登录失败, 执行跳转 attributes.addFlashAttribute("alert", 0); return "redirect:/login.htm"; &#125; &#125; &#125; 用RedirectAttributes类中的addFlashAttribute方法带回参数]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpingMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的VPS重装之路]]></title>
    <url>%2F2015%2F06%2F07%2Fnode%2Flinux%2Fnode-linux_02%2F</url>
    <content type="text"><![CDATA[这几天我在Linux下安装邮件服务器, 百试不通, 最后25端口, 直接崩掉了. 无奈只有重装系统, 这也是一个小白的悲哀吧. 1. 重装完之后, 设置免密登录 ssh-keygen -t rsa chmod 600 ~/.ssh chmod 700 ~/.ssh/authorized_keys ​ 2. 安装上传下载文件的工具 yum -y install lrzsz ​ 3. 安装 Shadowsocks 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 参考: https://teddysun.com/486.html ​ 4. 安装EwoMail1. 关闭selinuxvim /etc/sysconfig/selinux 将SELINUX=enforcing 改为 SELINUX=disabled 2. 创建swapfree -m 查看swap dd if=/dev/zero of=/mnt/swap bs=1M count=1024 创建1G的swap mkswap /mnt/swap 设置交换分区文件 swapon /mnt/swap 启动swap vim /etc/fstab 添加 /mnt/swap swap swap defaults 0 0 设置开机时自启用 swap 分区 3. 修改主机名EwoMail在安装后会默认使用域名前缀mail的主机名, 例如: 我的是mail.yuchen.pro vim /etc/sysconfig/network 添加 HOSTNAME = mail.yuchen.pro vim /etc/hosts 修改 127.0.0.1 对应的域名 hostname mail.yuchen.pro 4. 打开：http://ewomail.com/list-11.html 输入你的域名获取安装代码5. 安装完成后, cat /ewomail/config.ini 查看MySQL密码5. 安装 Javawget http://download.oracle.com/otn/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.tar.gz?AuthParam=1528779151_b5871543e1cc4204d7d0bb4db6e0b8fd 下载JDK tar -zxvf jdk-8u151-linux-x64.tar.gz 解压 mv jdk1.8.0_151/ /opt/ 修改目录 vim /etc/profile 配置环境变量123export JAVA_HOME=/opt/jdk1.8.0_151export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=. source /etc/profile 环境变量生效]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX 调用]]></title>
    <url>%2F2015%2F04%2F30%2Fnode%2Fjava%2Fnode-j2ee_02%2F</url>
    <content type="text"><![CDATA[Ajax调用, 并解析返回的数据 JSON 数据服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); JSONObject json = null; PrintWriter out = response.getWriter(); System.out.println("load in ...."); // 初始化数据 class Cat&#123; Cat (String name,int height ) &#123; this.height = height; this.name = name; &#125; int height; String name; &#125; ArrayList&lt;Cat&gt; list = new ArrayList&lt;Cat&gt;(); list.add(new Cat("Tom",20)); list.add(new Cat("Abby",30)); list.add(new Cat("Kitty",10)); list.add(new Cat("Julie",40)); // 定义返回值的容器 StringBuffer buffer = new StringBuffer(); // 当json返回 对象时, 外面必须加一对小括号 buffer.append("(&#123;"); for(int i = 0; i &lt; list.size(); i++)&#123; Map map = new HashedMap(); map.put("name", list.get(i).name); map.put("height", list.get(i).height); json = JSONObject.fromObject(map); buffer.append(i); buffer.append(":"); buffer.append(json.toString()); if(i != list.size()-1) &#123; buffer.append(","); &#125; &#125; buffer.append("&#125;)"); out.print(buffer); out.flush(); out.close(); &#125; 前端1234567891011121314151617181920212223$(function() &#123; $("#verify").click(function()&#123; var userName = $("#userName").val(); $.ajax(&#123; type: "post", url: "servlet/ResultJSON", async: true, data : "name=" + userName, dataType: "Text", success: function(data)&#123; alert(data); var objs = eval(data); try&#123; for (var i = 0; i &lt; 10; i++) &#123; var o = objs[i]; $("#result").append(o.name + "---" + o.height + "&lt;br /&gt;");&#125; &#125;catch(e)&#123; alert("数据往下没有了"); &#125; &#125; &#125;); &#125;);&#125;); XML 数据服务端12345678910111213141516171819202122232425262728293031323334353637public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); // 设置请求的字符集 // 修改响应的内容类型为xml response.setContentType("text/xml;charset=utf-8"); // 设置响应的字符集 // 返回的数据需要拼成xml格式 StringBuffer buffer = new StringBuffer(); buffer.append("&lt;message&gt;"); PrintWriter out = response.getWriter(); // 1. 获取参数 String para = request.getParameter("name"); // 2. 检查参数是否存 有问题 if(para == null || para.trim().length() == 0) &#123; buffer.append("用户名不能为空"); &#125; else &#123; // 3. 校验操作 if(para.equals("yuchen352416"))&#123; // 处理返回结果 buffer.append("用户名 [" + para + "] 已经存在,请使用其他用户名" ); &#125; else &#123; buffer.append("用户名 [" + para + "] 尚未存在,可以使用该用户名" ); &#125; &#125; buffer.append("&lt;/message&gt;"); // 4. 需要将用户感兴趣的xml内容返回给页面端,而不是将一个新的页面返回给用户 out.println(buffer.toString());&#125; 前端123456789101112131415161718$(function()&#123; $("#verify").click(function() &#123; var userName = $("#userName").val(); $.ajax(&#123; type: "post", url: "servlet/ResultXML", async: true, data : "name=" + userName, dataType: "xml", success: function(data)&#123; var jqueryObj = $(data); var message = jqueryObj.children(); var text = message.text(); $("#result").html(text); &#125; &#125;); &#125;);&#125;);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax 语法]]></title>
    <url>%2F2015%2F04%2F27%2Fnode%2Fnode-ajax_1%2F</url>
    <content type="text"><![CDATA[Ajax 语法 Ajax 常用方法 方法名 方法描述 $.ajax(); 执行异步HTTP(ajax)请求 $.ajaxComplete(); 当 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件 $.ajaxError(); 当 Ajax 请求完成且出现错误时注册要调用的处理程序。这是一个 Ajax 事件 $.ajaxSend(); 在 Ajax 请求发送之前显示一条消息 $.ajaxSetup(); 设置将来的 Ajax 请求的默认值 $.ajaxStart(); 当首个 Ajax 请求完成开始时注册要调用的处理程序。这是一个 Ajax 事件 $.ajaxStop(); 当所有 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件 $.ajaxSuccess(); 当 Ajax 请求成功完成时显示一条消息 $.get(); 使用 HTTP GET 请求从服务器加载数据 $.post(); 使用 HTTP POST 请求从服务器加载数据 $.getJSON(); 使用 HTTP GET 请求从服务器加载 JSON 编码数据 $.getScript(); 使用 HTTP GET 请求从服务器加载 JavaScript 文件，然后执行该文件 $.load(); 从服务器加载数据，然后把返回到 HTML 放入匹配元素 $.param(); 创建数组或对象的序列化表示，适合在 URL 查询字符串或 Ajax 请求中使用 $.serialize(); 将表单内容序列化为字符串 $.serializeArray(); 序列化表单元素，返回 JSON 数据结构数据 Ajax 常用属性 选项名 值类型 初始值 说明 async boolean true 非同期通信标志,为ture时,执行非同期通信; 为false时,执行同期通信. 在同期通信的情况下,浏览器回答前不能执行任何操作 beforeSend function - 通信前调用的AJAX Event(事件),返回值指定为 false时, 可以取消AJAX通讯 cache boolean true 是否缓冲通信结果的标志为true时,执行缓冲; 反之 不执行缓冲. 另外, 当 dataType 指定为script 或 jsonp时, 值为false complete function - Ajax通信结束时调用和Ajax Event,在success 或 error 调出后被调用 contentType string application/x-www-form-urlencoded 在向服务器发送数据时使用,指定content-type的值,几乎不用修改 data object/string - 指定发关给服务器的数值.当以属性的形式指定时,会被转换为query字符串 dataFilter function - 过滤从服务器返回的值,在只需取出所需时使用. 第 1个参数为 数据,第2个参数为dataType dataType string jQuery根据回答自动判断 指定服务器的返回值类型,省略时自动判断 error function - 通讯失败时调用的Ajax Event 参数分别是 : XMLHttpRequest对象, 错误内容和补充例外对象. 第2个参数为null以外值时,可以获取timeout,error,notmodified,parseerror 等值. global boolean true 是否使用ajaxComplete全局句柄的标志,为true 使用, 为false 不使用 ifModified boolean false 检查服务器应答中含有的Last-modified头,只有前一次的应答有变更时,才返回成功status. 为true时,检查; 为false时,不检查 jsonp string - 在执行jsonp请求的情况下使用. API方指定callback函数后,与success属性联系, 将作为callback函数被调用 processData boolean true data属性中指定的对象是否转换为query字符串的标志。初始值为true， 变换为 application/x-www-form-urlencoded 形式，以其他形式传输时，为false. scriptCharset string - 在dataType为jsonp或script 且Ajax执行页面与服务器中的字符集不同时指定 type string get 指定请求类型为post或get,初始值为get. url string 当前页面的URL 指定送出请求对象URL,初始值是向当前的页面通信 username string - 在执行需要HTTP连接认证时指定 password string - 在执行需要HTTP连接认证时指定 xhr function - 在Ajax的XMLHttpRequest对象生成时调用的callback函数.在IE中,生成ActiveXObject对象时也被调用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 笔记]]></title>
    <url>%2F2015%2F03%2F02%2Fnode%2Flinux%2Fnode-linux_01%2F</url>
    <content type="text"><![CDATA[Linux 笔记 在Linux下，你所能看到的都以文件形式存在（包括文件和设备）文件在Linux下，被看做文件设备(二进制文件和字符形式的文件)pwd 查看当前路径whoami 我是谁? hd 代表IDE硬盘hda 代表 IDE的第一个接口hdb 代表 IDE的第二个接口hda2 代表扩展分区,hda5 代表第一块硬盘上的第一个逻辑分区 挂载mount /dev/cdrom /mnt/cdr ( /dev/cdrom 设备路径, /mnt/cdr 设备映射路径[理论上 映射路径可以是任何位置,但约定俗成的把设备的映射路径放在 /mnt 下] ) 取消挂载umount /dev/cdrom(参数可以是设备,也可以是 挂载点) rmdir 删除路径mkdir 添加路径 Linux 启动过程 load bios —— 加载BIOS read MBR´s config to find out the OS —— 读取硬盘的引导扇区 load the kernel of the OS —— 根据引导扇区查找操作系统 init process starts —— 启动第一个进程 execute /etc/rc.d/sysinit —— rc.d （run command 运行命令 后台运行的命令） start other modules(etc/modules.conf) —— 加载设备的驱动程序 execute the run level scripts —— 系统启动时会运行相应层次的脚本。 execute /etc/rc.d/rc.local —— 可以设置自启软件 execute /bin/login —— 登录 shell started…. Linux 分区方式（手动分区和自动分区）手动分区： / —— 根分区 /usr —— 应用软件存放位置 /home —— 用户宿主目录的父目录 /var —— 存放临时文件 /boot —— 存放启动文件 128M is enough SWAP —— 交换分区（相当于windows的虚拟内存） 理论上交换分区的大小是物理内存的两倍 可以不建，但不建议，因为有的程序会默认使用 Inti0 - 系统停机状态1 - 单用户工作状态2 - 多用户状态（没有NFS - 网络文件系统）3 - 多用户状态（有NFS）4 - 系统未使用，留给用户5 - 图形界面6 - 系统正常关闭并重启 Linux 常用命令： shutdown now 现在关机ls 列出当前目录中的所有文件和子目录（以d开头的是目录，以 — 开头的是文件,以l打头的是一个链接）cd 既可以用决对路径，也可以是相对路径（cd.. 上层路径）pwd 显示当前路径mkdir 创建一个目录rmdir 删除一个目录（只能删除空目录）rm -rf 强制递归删除（全部删除 r —— 递归 f —— 强制）touch 创建文件（从linux技术角度，扩展命，没有意义，在linux下的扩展名只有提示意义）cp 复制mv 移动cat 查看文件内容tac 倒序输出文件内容more 查看文件里的内容(分屏显示)head [-n] &lt;文件名&gt; 查看指定文件的前n行find 查找文件（可以按文件名，日期，大小。。。。总之非常强大）whereis &lt;命令&gt; 命令存放的位置，已经这个命令的帮助文档的位置ln &lt;v.txt&gt; &lt;lv.txt&gt; 创建lv.txt的硬链接，指向v.txt（所谓硬链接，就是把v.txt中了内容复制到lv.txt中，不管其中哪个文件的内容被修改了，两个文件中的内容都是最后修改过的内容）ln -s &lt;v.txt&gt; &lt;lsv.txt&gt; 创建v.txt乱链接（相当于给v.txt加了一个快捷方式）echo $PATH 查看PATH 环境变量chown &lt;username&gt; &lt;filename&gt; 修改文件所有者grep &lt;要查找的内容&gt; &lt;要查找的文件&gt; 显示内容在文件的一整行date 显示和设置日期时间stat 显示指定文件的相关信息who\w 显示在线登录用户whoami 显示用户自己的身份id 显示当前用户的id信息hostname 显示主机信息uname 显示操作系统信息dmesg 显示系统启动信息du 显示指定文件(目录)已使用的磁盘空间的总量df 显示文件系统磁盘空间的使用情况free 显示当前内存和交换空间的使用情况fdisk -l 显示磁盘信息locale 显示当前语言环境wall 警告所有用户 VIM如果当前目录里有这个文件，就会打开这文件，如果没有，就会创建这个文件并打开vi编辑器，有两种模式（编辑模式，命令模式），刚一打开为命令模式，只能敲命令，在命令模式下按 a 添加内容，进入编辑模式，按２次 ESC 退出编辑模式，回到命令模式按 ： 及可输入命令w 保存q 退出q！ 不保存退出wq 保存退出dd 删除一行dw 删除一个单词wc 统计指定文件的行数,字数,字符数 etc目录下的passwd文件实际存放的是所有用户-类似于 testuser:x:501:502:/home/testuser:bin/bashtestuser 用户名x组为 501id为 502主目录 /home/testusershell bin/bash (shell 解释命令,和内核交流)[注:除了bash外,还有csh,ksh,bsh,和最原始的sh] 添加用户时,没有指定组的说,默认会添加一个和用户名相同的组linux 可以对用户组进行增删改操作当删除用户时,用户的文件不会被删除 文件权限 (共 10 位的权限描述) [ 第1位单独自己,往后每三个一组 ] [ r 可读, w 可写, x 可执行, - 没有任何权限 ] 第 1位: 以d开头的是目录, 以 — 开头的是文件, 以l打头的是一个链接 第 2位: 这个文件的所有者,有没有读的权限(有的话 r 没有的话 - )第 3位: 这个文件的所有者,有没有写的权限(有的话 w 没有的话 - )第 4位: 这个文件的所有者,有没有执行的权限(有的话 x 没有的话 - ) 第 5位: 这个文件的所有者同组的其他人,有没有读的权限(有的话 r 没有的话 - )第 6位: 这个文件的所有者同组的其他人,有没有写的权限(有的话 w 没有的话 - )第 7位: 这个文件的所有者同组的其他人,有没有执行的权限(有的话 x 没有的话 - ) 第 8位: 其他人,有没有读的权限(有的话 r 没有的话 - )第 9位: 其他人,有没有写的权限(有的话 w 没有的话 - )第10位: 其他人,有没有执行的权限(有的话 x 没有的话 - ) 一般: 拥有这个文件的人,可读可写,其他人只读,拥有这个目录的人,可读可写可执行,其他人可读可执行, u 文件拥有者g 同组的个o 其他人 chmod 修改权限(可直接 + - )例如: chmod g+w v.txt (其含义:给同组的人加可写权限) linux 用3个8进制数代表这三组权限,1 代表有权限, 0 代表没权限(例如 rwxr-xr–,就可以是111101100,也就是754) 管道例子: ls -Rl | more (把上一个命令的结果,交给 | 后的命令去处理) dmesg | grep eth0 (检查启动时的第一块网卡的信息) 命令替换 `(大键盘1左边的键)包起的命令,替换成执行结果,交给下面的管道 重定向重定向输入&gt;把执行结果的内容,输出到指定的文件(原文件内容清空)(例如: ls -l &gt; v.txt)&gt;&gt; 追加内容命令找不到的话,就不会做输出了重定向输出&lt; (例如: wall &lt; a.txt) 将a.txt中的内容作为警告信息 修改启动文件输入命令sudo gedit /etc/default/grub修改grub文件中内容:GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;更新grubsudo update-grub重启sudo reboot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 拼图实例]]></title>
    <url>%2F2015%2F03%2F01%2Fnode%2Fjavascript%2Fnode-javascript_15%2F</url>
    <content type="text"><![CDATA[jQuery 拼图实例 HTML 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;jQuery&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/bootstrap.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="css/bootstrap-responsive.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="css/user.css"/&gt; &lt;script src="js/jquery-2.1.3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/user.js" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container background-main"&gt; &lt;div class="image-item img1" id="img1"&gt;&lt;/div&gt; &lt;div class="image-item img2" id="img2"&gt;&lt;/div&gt; &lt;div class="image-item img3" id="img3"&gt;&lt;/div&gt; &lt;div class="image-item img4" id="img4"&gt;&lt;/div&gt; &lt;div class="image-item img5" id="img5"&gt;&lt;/div&gt; &lt;div class="image-item img6" id="img6"&gt;&lt;/div&gt; &lt;div class="image-item img7" id="img7"&gt;&lt;/div&gt; &lt;div class="image-item img8" id="img8"&gt;&lt;/div&gt; &lt;div class="image-item img9" id="img9"&gt;&lt;/div&gt; &lt;/div&gt; &lt;audio src="music/slide.mp3" id="music"&gt;&lt;/audio&gt; &lt;/body&gt; &lt;/html&gt; CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586.background-main&#123; margin-top: 20px; margin-left: auto; margin-right: auto; position: relative; &#125; .image-item&#123; width: 245px; height: 200px; position: absolute; /*background: no-repeat center top fixed;*/ /*background-size:100% 100%;*/ /*background-color: red;*/ float: left; &#125; .img1&#123; left: 0px; top: 0px; &#125; .img2&#123; left: 245px; top: 0px; &#125; .img3&#123; left: 490px; top: 0px; &#125; .img4&#123; left: 0px; top: 200px; &#125; .img5&#123; left: 245px; top: 200px; &#125; .img6&#123; left: 490px; top: 200px; &#125; .img7&#123; left: 0px; top: 400px; &#125; .img8&#123; left: 245px; top: 400px; &#125; .img9&#123; left: 490px; top: 400px; &#125; #img1&#123; background: url(../img/img0.png); background-size:100% 100%; &#125; #img2&#123; background: url(../img/img1.png); background-size:100% 100%; &#125; #img3&#123; background: url(../img/img2.png); background-size:100% 100%;&#125; #img4&#123; background: url(../img/img3.png); background-size:100% 100%;&#125; #img5&#123; background: url(../img/img4.png); background-size:100% 100%;&#125; #img6&#123; background: url(../img/img5.png); background-size:100% 100%;&#125; #img7&#123; background: url(../img/img6.png); background-size:100% 100%;&#125; #img8&#123; background: url(../img/img7.png); background-size:100% 100%; &#125; #img9&#123; background: url(../img/img8.png); background-size:100% 100%; &#125; JavaScript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105var sum = 0; // 存放所有方块对应值的和 var arr = []; // 存放8块图片的容器 window.onload = function() &#123; // 随机产生不相同的8个随机数 var index = []; for(var i = 0; i &lt; 8; i++)&#123; index[i] = parseInt(Math.random()*8); for(var j = 0; j &lt; i; j++)&#123; if(index[i] == index[j])&#123;break;&#125; &#125; if(j != i)&#123;i--;&#125; &#125; // 获得所有方块对应值的和 $.each($('.image-item'), function() &#123; sum += parseInt($(this).css("left")) + parseInt($(this).css("top")); &#125;); // 把浮动的8个方块的名字,存入容器 for(var i = 1; i &lt; 9; i++)&#123; var str = "img" + i; arr[i-1] = document.getElementById(str); &#125; // 打乱8块方块位置 for(var i = 0; i &lt; 8; i++) &#123; var mod = i - parseInt(i / 3) *3; var setLeft = mod * 245; var setTop = parseInt(i / 3) * 200; arr[index[i]].style.left = setLeft + "px"; arr[index[i]].style.top = setTop + "px"; &#125; // 隐藏第九块图片 $("#img9").hide(); // $("#img9").show(); // 绑定每块图片的单击事件 $('.image-item').click(function()&#123; // 存放单击图片对应的数值 var num = parseInt($(this).css("left")) + parseInt($(this).css("top")); // 存放当前8块方块对应值的和 var presentSum = 0; // 计算当前8块方块对应值的和 for(var i = 0; i &lt; arr.length; i++) &#123; presentSum += parseInt($(arr[i]).css("left")) + parseInt($(arr[i]).css("top")); &#125; // 存放当前空格对应的要数值 var notExist = 0; // 计算9块方格中,哪一块是空的 notExist = sum - presentSum; // 标识 var flag = notExist - num; // 触发声音 document.getElementById("music").play(); // 判断方块的移动方向 if(flag == 200 || flag == -200) &#123; var setTop = parseInt($(this).css("top")) + flag; // 上下移动方块(带动画) $(this).animate(&#123;top: setTop + "px"&#125;); &#125; else if(flag == 245 || flag == -245) &#123; var setLeft = parseInt($(this).css("left")) + flag; // 左右移动方块(带动画) $(this).animate(&#123;left: setLeft + "px"&#125;); &#125; // 判断是否拼好 var judge = []; // 存放当前所有方块对应的值 for(var i = 0; i &lt; 8; i++) &#123; judge[i] = parseInt(arr[i].style.left) + parseInt(arr[i].style.top); if(judge[i] == num) &#123; judge[i] += flag; &#125; &#125; for(var j = 0; j &lt; 8; j++) &#123; var mod = j - parseInt(j / 3) *3; var setLeft = mod * 245; var setTop = parseInt(j / 3) * 200; var temp = setLeft + setTop; if(temp != judge[j]) &#123; break; &#125; &#125; if(j == 8) &#123; // 显示第九块图片 $("#img9").slideDown(); // 取消单击绑定 $('.image-item').unbind("click") &#125; &#125;); &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 标签]]></title>
    <url>%2F2015%2F02%2F11%2Fnode%2Fnode-html_2%2F</url>
    <content type="text"><![CDATA[HTML5 标签 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!--...--&gt; 定义注释。&lt;!DOCTYPE&gt; 定义文档类型。&lt;a&gt; 定义超链接。 &lt;abbr&gt; 定义缩写。&lt;address&gt; 定义地址元素。&lt;area&gt; 定义图像映射中的区域。&lt;article&gt; 定义 article。&lt;aside&gt; 定义页面内容之外的内容。&lt;audio&gt; 定义声音内容。&lt;b&gt; 定义粗体文本。 &lt;base&gt; 定义页面中所有链接的基准 URL。&lt;bdo&gt; 定义文本显示的方向。 &lt;blockquote&gt; 定义长的引用。&lt;body&gt; 定义 body 元素。&lt;br&gt; 插入换行符。&lt;button&gt; 定义按钮。&lt;canvas&gt; 定义图形。&lt;caption&gt; 定义表格标题。&lt;cite&gt; 定义引用。&lt;code&gt; 定义计算机代码文本。&lt;col&gt; 定义表格列的属性。&lt;colgroup&gt; 定义表格列的分组。&lt;command&gt; 定义命令按钮。&lt;datalist&gt; 定义下拉列表。&lt;dd&gt; 定义定义的描述。 &lt;del&gt; 定义删除文本。 &lt;details&gt; 定义元素的细节。&lt;dfn&gt; 定义定义项目。 &lt;div&gt; 定义文档中的一个部分。&lt;dl&gt; 定义定义列表。 &lt;dt&gt; 定义定义的项目。&lt;em&gt; 定义强调文本。 &lt;embed&gt; 定义外部交互内容或插件。&lt;fieldset&gt; 定义 fieldset。&lt;figcaption&gt; 定义 figure 元素的标题。&lt;figure&gt; 定义媒介内容的分组，以及它们的标题。 &lt;footer&gt; 定义 section 或 page 的页脚。&lt;form&gt; 定义表单。 &lt;h1&gt; to &lt;h6&gt; 定义标题 1 到标题 6。&lt;head&gt; 定义关于文档的信息。&lt;header&gt; 定义 section 或 page 的页眉。&lt;hgroup&gt; 定义有关文档中的 section 的信息。 &lt;hr&gt; 定义水平线。&lt;html&gt; 定义 html 文档。&lt;i&gt; 定义斜体文本。 &lt;iframe&gt; 定义行内的子窗口（框架）。&lt;img&gt; 定义图像。 &lt;input&gt; 定义输入域。&lt;ins&gt; 定义插入文本。&lt;keygen&gt; 定义生成密钥。 &lt;kbd&gt; 定义键盘文本。&lt;label&gt; 定义表单控件的标注。&lt;legend&gt; 定义 fieldset 中的标题。&lt;li&gt; 定义列表的项目。&lt;link&gt; 定义资源引用。&lt;map&gt; 定义图像映射。&lt;mark&gt; 定义有记号的文本。&lt;menu&gt; 定义菜单列表。&lt;meta&gt; 定义元信息。 &lt;meter&gt; 定义预定义范围内的度量。&lt;nav&gt; 定义导航链接。 &lt;noscript&gt; 定义 noscript 部分。&lt;object&gt; 定义嵌入对象。&lt;ol&gt; 定义有序列表。&lt;optgroup&gt; 定义选项组。&lt;option&gt; 定义下拉列表中的选项。&lt;output&gt; 定义输出的一些类型。&lt;p&gt; 定义段落。 &lt;param&gt; 为对象定义参数。&lt;pre&gt; 定义预格式化文本。&lt;progress&gt; 定义任何类型的任务的进度。&lt;q&gt; 定义短的引用。&lt;rp&gt; 定义若浏览器不支持 ruby 元素显示的内容。&lt;rt&gt; 定义 ruby 注释的解释。&lt;ruby&gt; 定义 ruby 注释。 &lt;samp&gt; 定义样本计算机代码。&lt;script&gt; 定义脚本。&lt;section&gt; 定义 section。&lt;select&gt; 定义可选列表。&lt;small&gt; 定义小号文本。&lt;source&gt; 定义媒介源。&lt;span&gt; 定义文档中的 section。 &lt;strong&gt; 定义强调文本。&lt;style&gt; 定义样式定义。&lt;sub&gt; 定义下标文本。&lt;summary&gt; 定义 details 元素的标题。 &lt;sup&gt; 定义上标文本。&lt;table&gt; 定义表格。&lt;tbody&gt; 定义表格的主体。&lt;td&gt; 定义表格单元。&lt;textarea&gt; 定义 textarea。&lt;tfoot&gt; 定义表格的脚注。&lt;th&gt; 定义表头。&lt;thead&gt; 定义表头。&lt;time&gt; 定义日期/时间。&lt;title&gt; 定义文档的标题。&lt;tr&gt; 定义表格行。 &lt;ul&gt; 定义无序列表。 &lt;var&gt; 定义变量。&lt;video&gt; 定义视频。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
